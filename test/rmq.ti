external abort : ∀a. a = "abort"
let not : Bool -> Bool =
      fun (x : Bool) ->
        match x with
        | True -> False
        | False -> True
let (&&) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> y
        | False -> False
let (||) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> True
        | False -> y
external neg : Int -> Int = "neg"
external (+) : Int -> Int -> Int = "add"
external (-) : Int -> Int -> Int = "sub"
external (*) : Int -> Int -> Int = "mul"
external (/) : Int -> Int -> Int = "div"
external (%) : Int -> Int -> Int = "mod"
external (==) : Int -> Int -> Bool = "eq"
external (!=) : Int -> Int -> Bool = "ne"
external (<) : Int -> Int -> Bool = "lt"
external (<=) : Int -> Int -> Bool = "le"
external (>=) : Int -> Int -> Bool = "ge"
external (>) : Int -> Int -> Bool = "gt"
let foldr : ∀a b. (a -> b -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : a -> b -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil -> y0
          | Cons x xs -> f x (foldr f y0 xs)
let foldl : ∀a b. (b -> a -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : b -> a -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil -> y0
          | Cons x xs -> foldl f (f y0 x) xs
let take : ∀a. Int -> List a -> List a =
      fun @a ->
        fun (n : Int) (xs : List a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False ->
            match xs with
            | Nil -> Nil @a
            | Cons x xs -> Cons @a x (take ((-) n 1) xs)
let nth : ∀a. List a -> Int -> a =
      fun @a ->
        fun (xs : List a) (n : Int) ->
          match xs with
          | Nil -> abort @a
          | Cons x xs ->
            match (<=) n 0 with
            | True -> x
            | False -> nth xs ((-) n 1)
let zip_with : ∀a b c. (a -> b -> c) -> List a -> List b -> List c =
      fun @a @b @c ->
        fun (f : a -> b -> c) (xs : List a) (ys : List b) ->
          match xs with
          | Nil -> Nil @c
          | Cons x xs ->
            match ys with
            | Nil -> Nil @c
            | Cons y ys -> Cons @c (f x y) (zip_with f xs ys)
let partition : ∀a. (a -> Bool) -> List a -> Pair (List a) (List a) =
      fun @a ->
        fun (p : a -> Bool) (xs : List a) ->
          let rec part_p : List a -> Pair (List a) (List a) =
                    fun (xs : List a) ->
                      match xs with
                      | Nil -> Pair @(List a) @(List a) (Nil @a) (Nil @a)
                      | Cons x xs ->
                        match part_p xs with
                        | Pair ys zs ->
                          match p x with
                          | True -> Pair @(List a) @(List a) (Cons @a x ys) zs
                          | False -> Pair @(List a) @(List a) ys (Cons @a x zs)
          in
          part_p xs
let append : ∀a. List a -> List a -> List a =
      fun @a ->
        fun (xs : List a) (ys : List a) ->
          match xs with
          | Nil -> ys
          | Cons x xs -> Cons @a x (append xs ys)
let concat : ∀a. List (List a) -> List a =
      fun @a -> foldr @(List a) @(List a) (append @a) (Nil @a)
let map : ∀a b. (a -> b) -> List a -> List b =
      fun @a @b ->
        fun (f : a -> b) (xs : List a) ->
          match xs with
          | Nil -> Nil @b
          | Cons x xs -> Cons @b (f x) (map f xs)
let concat_map : ∀a b. (b -> List a) -> List b -> List a =
      fun @a @b ->
        fun (f : b -> List a) (xs : List b) ->
          concat @a (map @b @(List a) f xs)
let length : ∀a. List a -> Int =
      fun @a -> foldr @a @Int (fun (x : a) (l : Int) -> (+) 1 l) 0
let replicate : ∀a. Int -> a -> List a =
      fun @a ->
        fun (n : Int) (x : a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False -> Cons @a x (replicate ((-) n 1) x)
let insert_tree : Int -> Tree Int -> Tree Int =
      fun (x : Int) (t : Tree Int) ->
        match t with
        | Leaf -> Branch @Int (Leaf @Int) x (Leaf @Int)
        | Branch l y r ->
          match (<=) x y with
          | True -> Branch @Int (insert_tree x l) y r
          | False -> Branch @Int l y (insert_tree x r)
let in_order : ∀a. Tree a -> List a =
      fun @a ->
        fun (t : Tree a) ->
          match t with
          | Leaf -> Nil @a
          | Branch l x r -> append @a (in_order l) (Cons @a x (in_order r))
external return : ∀a. a -> IO a = "return"
external print : Int -> IO Unit = "print"
external input : IO Int = "input"
external (>>=) : ∀a b. IO a -> (a -> IO b) -> IO b = "bind"
let (;) : ∀a b. IO b -> IO a -> IO a =
      fun @a @b ->
        fun (m1 : IO b) (m2 : IO a) -> (>>=) @b @a m1 (fun (x : b) -> m2)
let sequence_io : ∀a. List (IO a) -> IO (List a) =
      fun @a ->
        fun (ms : List (IO a)) ->
          match ms with
          | Nil -> return @(List a) (Nil @a)
          | Cons m ms ->
            (>>=) @a @(List a) m (fun (x : a) ->
                                    (>>=) @(List a) @(List a) (sequence_io ms) (fun (xs : List a) ->
                                                                                  return @(List a) (Cons @a x xs)))
let iter_io : ∀a. (a -> IO Unit) -> List a -> IO Unit =
      fun @a ->
        fun (f : a -> IO Unit) ->
          foldr @a @(IO Unit) (fun (x : a) (m : IO Unit) ->
                                 (;) @Unit (f x) m) (return @Unit Unit)
let print_list : List Int -> IO Unit = iter_io @Int print
let nats : List Int =
      let rec nats_from : Int -> List Int =
                fun (n : Int) -> Cons @Int n (nats_from ((+) n 1))
      in
      nats_from 0
let pair : ∀a. (a -> a -> a) -> List a -> List a =
      fun @a ->
        fun (op : a -> a -> a) (xs1 : List a) ->
          match xs1 with
          | Nil -> Nil @a
          | Cons x1 Nil -> xs1
          | Cons x1 (Cons x2 xs3) -> Cons @a (op x1 x2) (pair op xs3)
let single : ∀a. Int -> a -> RmqTree a =
      fun @a ->
        fun (i : Int) (x : a) ->
          RmqNode @a i i x (RmqEmpty @a) (RmqEmpty @a)
let combine : ∀a. (a -> a -> a) -> RmqTree a -> RmqTree a -> RmqTree a =
      fun @a ->
        fun (op : a -> a -> a) (t1 : RmqTree a) (t2 : RmqTree a) ->
          match t1 with
          | RmqEmpty -> abort @(RmqTree a)
          | RmqNode s1 _ v1 _ _ ->
            match t2 with
            | RmqEmpty -> abort @(RmqTree a)
            | RmqNode _ e2 v2 _ _ -> RmqNode @a s1 e2 (op v1 v2) t1 t2
let build : ∀a. (a -> a -> a) -> List a -> RmqTree a =
      fun @a ->
        fun (op : a -> a -> a) (xs : List a) ->
          let rec run : List (RmqTree a) -> RmqTree a =
                    fun (ts : List (RmqTree a)) ->
                      match ts with
                      | Nil -> abort @(RmqTree a)
                      | Cons t1 Nil -> t1
                      | Cons t1 (Cons _ _) -> run (pair @(RmqTree a) (combine @a op) ts)
          in
          run (zip_with @Int @a @(RmqTree a) (single @a) nats xs)
let query : ∀a. a -> (a -> a -> a) -> Int -> Int -> RmqTree a -> a =
      fun @a ->
        fun (one : a) (op : a -> a -> a) (q_lo : Int) (q_hi : Int) ->
          let rec aux : RmqTree a -> a =
                    fun (t : RmqTree a) ->
                      match t with
                      | RmqEmpty -> one
                      | RmqNode t_lo t_hi value left right ->
                        match (||) ((<) q_hi t_lo) ((>) q_lo t_hi) with
                        | True -> one
                        | False ->
                          match (&&) ((<=) q_lo t_lo) ((<=) t_hi q_hi) with
                          | True -> value
                          | False -> op (aux left) (aux right)
          in
          aux
let infinity : Int = 1000000000
let min : Int -> Int -> Int =
      fun (x : Int) (y : Int) ->
        match (<=) x y with
        | True -> x
        | False -> y
let replicate_io : ∀a. Int -> IO a -> IO (List a) =
      fun @a ->
        fun (n : Int) (act : IO a) ->
          sequence_io @a (replicate @(IO a) n act)
let main : IO Unit =
      (>>=) @Int @Unit input (fun (n : Int) ->
                                (>>=) @Int @Unit input (fun (m : Int) ->
                                                          (>>=) @(List Int) @Unit (replicate_io @Int n input) (fun (xs : List Int) ->
                                                                                                                 let t : RmqTree Int =
                                                                                                                       build @Int min xs
                                                                                                                 in
                                                                                                                 (>>=) @(List Unit) @Unit (replicate_io @Unit m ((>>=) @Int @Unit input (fun (lo : Int) ->
                                                                                                                                                                                           (>>=) @Int @Unit input (fun (hi : Int) ->
                                                                                                                                                                                                                     let res : Int =
                                                                                                                                                                                                                           query @Int infinity min lo hi t
                                                                                                                                                                                                                     in
                                                                                                                                                                                                                     print res)))) (fun (x : List Unit) ->
                                                                                                                                                                                                                                      return @Unit Unit))))
