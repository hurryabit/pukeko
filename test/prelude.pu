-- The Pukeko prelude.

-- Fundamental functions
val abort : a
asm abort

-- Unit
type Unit =
  | Unit

-- Booleans
type Bool =
  | False
  | True

val not : Bool -> Bool
let not x = if x then False else True

val prefix_and : Bool -> Bool -> Bool
let prefix_and x y = if x then y     else False

val prefix_or  : Bool -> Bool -> Bool
let prefix_or  x y = if x then True  else y

-- Integers
type Int

val neg : Int -> Int
asm neg

val prefix_add : Int -> Int -> Int
asm prefix_add

val prefix_sub : Int -> Int -> Int
asm prefix_sub

val prefix_mul : Int -> Int -> Int
asm prefix_mul

val prefix_div : Int -> Int -> Int
asm prefix_div

val prefix_mod : Int -> Int -> Int
asm prefix_mod

val prefix_eq : Int -> Int -> Bool
asm prefix_eq

val prefix_ne : Int -> Int -> Bool
asm prefix_ne

val prefix_lt : Int -> Int -> Bool
asm prefix_lt

val prefix_le : Int -> Int -> Bool
asm prefix_le

val prefix_ge : Int -> Int -> Bool
asm prefix_ge

val prefix_gt : Int -> Int -> Bool
asm prefix_gt

-- Some fundamental types
type Pair a b =
  | Pair a b

type Option a =
  | None
  | Some a

type Choice a b =
  | First  a
  | Second b

-- Lists
type List a =
  | Nil
  | Cons a (List a)

val foldr : (a -> b -> b) -> b -> List a -> b
let rec foldr f y0 xs =
  match xs with
  | Nil       -> y0
  | Cons x xs -> f x (foldr f y0 xs)

val foldl : (b -> a -> b) -> b -> List a -> b
let rec foldl f y0 xs =
  match xs with
  | Nil -> y0
  | Cons x xs -> foldl f (f y0 x) xs

val take : Int -> List a -> List a
let rec take n xs =
  if n <= 0 then
    Nil
  else
    match xs with
    | Nil       -> Nil
    | Cons x xs -> Cons x (take (n-1) xs)

val nth : List a -> Int -> a
let rec nth xs n =
  match xs with
  | Nil -> abort
  | Cons x xs -> if n <= 0 then x else nth xs (n-1)

val zip_with : (a -> b -> c) -> List a -> List b -> List c
let rec zip_with f xs ys =
  match xs with
  | Nil -> Nil
  | Cons x xs ->
    match ys with
    | Nil -> Nil
    | Cons y ys -> Cons (f x y) (zip_with f xs ys)

val partition : (a -> Bool) -> List a -> Pair (List a) (List a)
let rec partition p xs =
  let rec part_p xs =
    match xs with
    | Nil -> Pair Nil Nil
    | Cons x xs ->
      match part_p xs with
      | Pair ys zs ->
        if p x then
          Pair (Cons x ys) zs
        else
          Pair ys (Cons x zs)
  in
  part_p xs

val append : List a -> List a -> List a
let rec append xs ys =
  match xs with
  | Nil -> ys
  | Cons x xs -> Cons x (append xs ys)

val concat : List (List a) -> List a
let concat = foldr append Nil

val map : (a -> b) -> List a -> List b
let rec map f xs =
  match xs with
  | Nil -> Nil
  | Cons x xs -> Cons (f x) (map f xs)

val concat_map : (a -> List b) -> List a -> List b
let concat_map f xs = concat (map f xs)

val length : List a -> Int
let length = foldr (fun x l -> 1+l) 0

-- Binary trees
type Tree a =
  | Leaf
  | Branch (Tree a) a (Tree a)

val insert_tree : Int -> Tree Int -> Tree Int
let rec insert_tree x t =
  match t with
  | Leaf -> Branch Leaf x Leaf
  | Branch l y r ->
    if x <= y then
      Branch (insert_tree x l) y r
    else
      Branch l y (insert_tree x r)

val in_order : Tree a -> List a
let rec in_order t =
  match t with
  | Leaf -> Nil
  | Branch l x r -> append (in_order l) (Cons x (in_order r))

-- IO
type IO a

val return : a -> IO a
asm return

val print : Int -> IO Unit
asm print

val input : IO Int
asm input

val prefix_bind : IO a -> (a -> IO b) -> IO b
asm prefix_bind

val prefix_semi : IO Unit -> IO a -> IO a
let prefix_semi m1 m2 = m1 >>= (fun x -> m2)

val iter_io : (a -> IO Unit) -> List a -> IO Unit
let iter_io f = foldr (fun x m -> f x; m) (return Unit)

val print_list : List Int -> IO Unit
let print_list = iter_io print
