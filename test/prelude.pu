-- The Pukeko prelude.
let not x = if x then False else True in
let prefix_and x y = if x then y     else False in
let prefix_or  x y = if x then True  else y     in
let prefix_semi m1 m2 = m1 >>= (fun (x : Unit) -> m2) in
letrec foldr f y0 xs =
  match xs with
  | Nil       -> y0
  | Cons x xs -> f x (foldr f y0 xs)
in
letrec take n xs =
  if n <= 0 then
    Nil
  else
    match xs with
    | Nil       -> Nil
    | Cons x xs -> Cons x (take (n-1) xs)
in
letrec zip_with f xs ys =
  match xs with
  | Nil -> Nil
  | Cons x xs ->
    match ys with
    | Nil -> Nil
    | Cons y ys -> Cons (f x y) (zip_with f xs ys)
in
letrec partition p xs =
  letrec part_p xs =
    match xs with
    | Nil -> Pair Nil Nil
    | Cons x xs ->
      match part_p xs with
      | Pair ys zs ->
        if p x then
          Pair (Cons x ys) zs
        else
          Pair ys (Cons x zs)
  in
  part_p xs
in
letrec append xs ys =
  match xs with
  | Nil -> ys
  | Cons x xs -> Cons x (append xs ys)
in
let concat = foldr append Nil in
letrec map f xs =
  match xs with
  | Nil -> Nil
  | Cons x xs -> Cons (f x) (map f xs)
in
let concat_map f xs = concat (map f xs) in
let length = foldr (fun x l -> 1+l) 0 in
let iter_m f = foldr (fun x m -> f x; m) (return Unit) in
let print_list = iter_m print in
1
