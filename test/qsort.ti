external abort : ∀a. a = "abort"
let not : Bool -> Bool =
      fun (x : Bool) ->
        match x with
        | True -> False
        | False -> True
let (&&) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> y
        | False -> False
let (||) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> True
        | False -> y
external neg : Int -> Int = "neg"
external (+) : Int -> Int -> Int = "add"
external (-) : Int -> Int -> Int = "sub"
external (*) : Int -> Int -> Int = "mul"
external (/) : Int -> Int -> Int = "div"
external (%) : Int -> Int -> Int = "mod"
external (==) : Int -> Int -> Bool = "eq"
external (!=) : Int -> Int -> Bool = "ne"
external (<) : Int -> Int -> Bool = "lt"
external (<=) : Int -> Int -> Bool = "le"
external (>=) : Int -> Int -> Bool = "ge"
external (>) : Int -> Int -> Bool = "gt"
let foldr : ∀a b. (a -> b -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : a -> b -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil @a -> y0
          | Cons @a x xs -> f x (foldr @a @b f y0 xs)
let foldl : ∀a b. (b -> a -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : b -> a -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil @a -> y0
          | Cons @a x xs -> foldl @a @b f (f y0 x) xs
let take : ∀a. Int -> List a -> List a =
      fun @a ->
        fun (n : Int) (xs : List a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False ->
            match xs with
            | Nil @a -> Nil @a
            | Cons @a x xs -> Cons @a x (take @a ((-) n 1) xs)
let nth : ∀a. List a -> Int -> a =
      fun @a ->
        fun (xs : List a) (n : Int) ->
          match xs with
          | Nil @a -> abort @a
          | Cons @a x xs ->
            match (<=) n 0 with
            | True -> x
            | False -> nth @a xs ((-) n 1)
let zip_with : ∀a b c. (a -> b -> c) -> List a -> List b -> List c =
      fun @a @b @c ->
        fun (f : a -> b -> c) (xs : List a) (ys : List b) ->
          match xs with
          | Nil @a -> Nil @c
          | Cons @a x xs ->
            match ys with
            | Nil @b -> Nil @c
            | Cons @b y ys -> Cons @c (f x y) (zip_with @a @b @c f xs ys)
let partition : ∀a. (a -> Bool) -> List a -> Pair (List a) (List a) =
      fun @a ->
        fun (p : a -> Bool) (xs : List a) ->
          let rec part_p : List a -> Pair (List a) (List a) =
                    fun (xs : List a) ->
                      match xs with
                      | Nil @a -> Pair @(List a) @(List a) (Nil @a) (Nil @a)
                      | Cons @a x xs ->
                        match part_p xs with
                        | Pair @(List a) @(List a) ys zs ->
                          match p x with
                          | True -> Pair @(List a) @(List a) (Cons @a x ys) zs
                          | False -> Pair @(List a) @(List a) ys (Cons @a x zs)
          in
          part_p xs
let append : ∀a. List a -> List a -> List a =
      fun @a ->
        fun (xs : List a) (ys : List a) ->
          match xs with
          | Nil @a -> ys
          | Cons @a x xs -> Cons @a x (append @a xs ys)
let concat : ∀a. List (List a) -> List a =
      fun @a -> foldr @(List a) @(List a) (append @a) (Nil @a)
let map : ∀a b. (a -> b) -> List a -> List b =
      fun @a @b ->
        fun (f : a -> b) (xs : List a) ->
          match xs with
          | Nil @a -> Nil @b
          | Cons @a x xs -> Cons @b (f x) (map @a @b f xs)
let concat_map : ∀a b. (a -> List b) -> List a -> List b =
      fun @a @b ->
        fun (f : a -> List b) (xs : List a) ->
          concat @b (map @a @(List b) f xs)
let length : ∀a. List a -> Int =
      fun @a -> foldr @a @Int (fun (x : a) (l : Int) -> (+) 1 l) 0
let replicate : ∀a. Int -> a -> List a =
      fun @a ->
        fun (n : Int) (x : a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False -> Cons @a x (replicate @a ((-) n 1) x)
let insert_tree : Int -> Tree Int -> Tree Int =
      fun (x : Int) (t : Tree Int) ->
        match t with
        | Leaf @Int -> Branch @Int (Leaf @Int) x (Leaf @Int)
        | Branch @Int l y r ->
          match (<=) x y with
          | True -> Branch @Int (insert_tree x l) y r
          | False -> Branch @Int l y (insert_tree x r)
let in_order : ∀a. Tree a -> List a =
      fun @a ->
        fun (t : Tree a) ->
          match t with
          | Leaf @a -> Nil @a
          | Branch @a l x r ->
            append @a (in_order @a l) (Cons @a x (in_order @a r))
external return : ∀a. a -> IO a = "return"
external print : Int -> IO Unit = "print"
external input : IO Int = "input"
external (>>=) : ∀a b. IO a -> (a -> IO b) -> IO b = "bind"
let (;) : ∀a. IO Unit -> IO a -> IO a =
      fun @a ->
        fun (m1 : IO Unit) (m2 : IO a) ->
          (>>=) @Unit @a m1 (fun (x : Unit) -> m2)
let sequence_io : ∀a. List (IO a) -> IO (List a) =
      fun @a ->
        fun (ms : List (IO a)) ->
          match ms with
          | Nil @(IO a) -> return @(List a) (Nil @a)
          | Cons @(IO a) m ms ->
            (>>=) @a @(List a) m (fun (x : a) ->
                                    (>>=) @(List a) @(List a) (sequence_io @a ms) (fun (xs : List a) ->
                                                                                     return @(List a) (Cons @a x xs)))
let iter_io : ∀a. (a -> IO Unit) -> List a -> IO Unit =
      fun @a ->
        fun (f : a -> IO Unit) ->
          foldr @a @(IO Unit) (fun (x : a) (m : IO Unit) ->
                                 (;) @Unit (f x) m) (return @Unit Unit)
let print_list : List Int -> IO Unit = iter_io @Int print
let qsort : List Int -> List Int =
      fun (xs : List Int) ->
        match xs with
        | Nil @Int -> Nil @Int
        | Cons @Int x xs ->
          match partition @Int (fun (y : Int) -> (<) y x) xs with
          | Pair @(List Int) @(List Int) ys zs ->
            append @Int (qsort ys) (Cons @Int x (qsort zs))
let main : IO Unit =
      (>>=) @Int @Unit input (fun (n : Int) ->
                                (>>=) @(List Int) @Unit (sequence_io @Int (replicate @(IO Int) n input)) (fun (xs : List Int) ->
                                                                                                            iter_io @Int print (qsort xs)))
