-- SECTION type resolver

-- SUBSECTION type cons

-- TEST unknown in type definition
-- FAILURE 2:3: unknown type constructor: Bad
type Typ =
  | Con Bad

-- TEST unknown in function declaration
-- FAILURE 1:1: unknown type constructor: Typ
val bad : Typ

-- TEST duplicate in one type definition
-- FAILURE 2:6: duplicate type constructor: Typ
type Typ
 and Typ

-- TEST duplicate in two type definitions
-- FAILURE 1:6: duplicate type constructor: Int
type Int

-- SUBSECTION data constructor

-- TEST unknown in expression
-- FAILURE 1:11: unknown data constructor: Con
let bad = Con

-- TEST unknown in pattern
-- FAILURE 2:3: unknown data constructor: Con
let f x =
  match x with
  | Con -> 1

-- TEST duplicate in one type
-- FAILURE 3:3: duplicate data constructor: Con
type Typ =
  | Con
  | Con

-- TEST duplicate in mutually recursive types
-- FAILURE 4:3: duplicate data constructor: Con
type Typ1 =
  | Con
and Typ2 =
  | Con

-- TEST duplicate in two types
-- FAILURE 2:3: duplicate data constructor: Nil
type Typ =
  | Nil


-- SECTION kind checker

-- SUBSECTION type definition

-- TEST underapplication in one definition
-- FAILURE 3:3: cannot unify kinds _3 -> * and *
type Typ1 a
and Typ2 =
  | Con Typ1

-- TEST underapplication in recursive definition
-- FAILURE 2:3: cannot unify kinds _3 -> * and *
type Typ a b =
  | Con (Typ a)

-- TEST underapplication in two definitions
-- FAILURE 2:3: cannot unify kinds * -> * and *
type Typ =
  | Con List

-- TEST overapplication in one definition
-- FAILURE 3:3: cannot unify kinds * and _6 -> *
type Typ1 a
and Typ2 a =
  | Con (Typ1 a a)

-- TEST overapplication in recursive definition
-- FAILURE 2:3: cannot unify kinds * and _4 -> *
type Typ a =
  | Con (Typ a a)

-- TEST overapplication in two definitions
-- FAILURE 2:3: cannot unify kinds * and _3 -> *
type Typ a =
  | Con (Int a)

-- TEST unbound type variable
-- FAILURE 2:3: unknown type variable: b
type Typ a =
  | Con b

-- XTEST repeated type variable
-- SUCCESS
type Typ a a =
  | Con a

-- TEST self application of type variable
-- FAILURE 2:3: occurs check
type Typ f =
  | Con (f f)

-- TEST type variable of kinds * and * -> *
-- FAILURE 2:3: cannot unify kinds * and _4 -> *
type Typ f a =
  | Con f (f a)

-- TEST type variable of kinds * -> * and * -> * -> *
-- FAILURE 2:3: cannot unify kinds _5 -> * and *
type Typ f a b =
  | Con (f a b) (f a)

-- TEST phantom type variable has kind *
-- FAILURE 6:3: cannot unify kinds * -> * and *
type Typ1 a =
  | Con1
and Typ2 a b =
  | Con2 (a b)
type Typ3 f a =
  | Con3 (Typ1 f) (Typ2 f a)


-- SUBSECTION function declaration

-- TEST underapplication
-- FAILURE 1:1: cannot unify kinds * -> * and *
val bad : List
let bad = abort

-- TEST overapplication
-- FAILURE 1:1: cannot unify kinds * and * -> *
val bad : Unit Int
let bad = abort


-- SECTION declaration/definition checker

-- SUBSECTION too many declarations

-- TEST duplicate declaration
-- FAILURE 2:1: duplicate declaration of function: f
val f : a -> a
val f : a -> a

-- TEST redeclaration
-- FAILURE 1:1: duplicate declaration of function: not
val not : Bool -> Bool

-- TEST missing definition
-- FAILURE 1:1: declared but undefined function: f
val f : a -> a

-- SUBSECTION duplicate definition

-- TEST two definitions
-- FAILURE 1:5: duplicate definition of function: not
let not x = x

-- TEST parallel definition
-- FAILURE 3:5: duplicate definition of function: f
val f : a -> a
let f x = x
and f x = x

-- TEST mutually recursive definition
-- FAILURE 3:5: duplicate definition of function: f
val f : a -> a
let rec f x = x
and f x = x

-- SUBSECTION definition of undeclared function

-- TEST normal definition
-- FAILURE 1:5: undeclared function: f
let f x = x

-- TEST recursive definition
-- FAILURE 1:9: undeclared function: f
let rec f x = f x

-- TEST parallel definition
-- FAILURE 3:5: undeclared function: g
val f : a -> a
let f x = x
and g x = x

-- TEST mutually recursive definition
-- FAILURE 3:5: undeclared function: g
val f : a -> a
let rec f x = x
and g x = x

-- TEST post declaration
-- FAILURE 1:5: undeclared function: f
let f x = x
val f : a -> a

-- TEST external
-- FAILURE 1:1: undeclared function: f
external f = "f"

-- SUBSECTION call of undeclared function

-- TEST one definition
-- FAILURE 2:11: unknown variable: g
val f : x -> x
let f a = g a

-- TEST recursive definition
-- FAILURE 2:15: unknown variable: g
val f : x -> x
let rec f a = g a

-- TEST post declaration
-- FAILURE 2:11: unknown variable: g
val f : a -> a
let f x = g x
val g : a -> a

-- SUBSECTION call of undefined function

-- TEST call of other
-- FAILURE 3:11: unknown variable: g
val f : a -> a
val g : a -> a
let f x = g x

-- TEST call of self
-- FAILURE 2:11: unknown variable: f
val f : a -> a
let f x = f x

-- TEST backward call in parallel
-- FAILURE 4:11: unknown variable: f
val f : a -> a
val g : a -> a
let f x = x
and g x = f x

-- TEST forward call in parallel
-- FAILURE 3:11: unknown variable: g
val f : a -> a
val g : a -> a
let f x = g x
and g x = x

-- SECTION type checker

-- SUBSECTION data constructor

-- TEST underapplication in expression
-- FAILURE 2:5: mismatching types Option and (->) _1
val bad : Option a
let bad = Some

-- TEST overapplication in expression
-- FAILURE 2:11: mismatching types Option and (->) _1
val f : a -> Option a
let f x = Some x x

-- TEST underapplication in pattern
-- FAILURE 3:3: data constructor 'Cons' expects 2 arguments
val f : List a -> a
let f x =
  match x with
  | Cons y -> y

-- TEST overapplication in pattern
-- FAILURE 3:3: data constructor 'Some' expects 1 arguments
val f : Option a -> a
let f x =
  match x with
  | Some y _ -> y

-- SUBSECTION unification

-- TEST type constructor vs type cons
-- FAILURE 2:5: mismatching types Unit and Int
val bad : Unit
let bad = 1

-- TEST type constructor vs arrow
-- FAILURE 2:5: mismatching types Option and (->) _1
val bad : Option a
let bad = fun y -> y

-- TEST arrow vs type cons
-- FAILURE 2:5: mismatching types a -> b and Unit
val f : a -> b
let f = Unit

-- TEST qvar vs qvar
-- FAILURE 2:5: mismatching types b and a
val f : a -> b
let f x = x

-- TEST qvar vs type cons
-- FAILURE 2:5: mismatching types a and Int
val bad : a
let bad = 1

-- TEST qvar vs arrow
-- FAILURE 2:5: mismatching types a and _1 -> _1
val bad : a
let bad = fun y -> y

-- TEST in type cons, 1
-- FAILURE 2:5: mismatching types b and a
val f : Option a -> Option b
let f x = x

-- TEST in type cons, 2
-- FAILURE 2:5: mismatching types c and b
val f : Pair a b -> Pair a c
let f x = x

-- TEST in lhs of arrow
-- FAILURE 2:5: mismatching types b and a
val f : (a -> c) -> (b -> c)
let f x = x

-- TEST in rhs of arrow
-- FAILURE 2:5: mismatching types c and b
val f : (a -> b) -> (a -> c)
let f x = x

-- TEST occurs check
-- FAILURE 2:11: '_3' occurs in List _3
val bad : List a
let bad = let rec x = Cons x Nil in x

-- TEST no overgeneralization
-- FAILURE 4:5: mismatching types Int and Bool
val f : Int
let f =
  let g x =
    let h y = x in
    if h True then 0 else h False
  in
  0


-- SUBSECTION misc

-- TEST function application unifies
-- FAILURE 4:5: mismatching types b and a
val f : a -> a
external f = "f"
val g : a -> b
let g x = f x

-- TEST var instantiation
-- SUCCESS
type A
type B
val x : a
external x = "x"
val f : A -> B -> A
external f = "f"
val y : A
let y = f x x

-- TEST data constructor instantiation
-- SUCCESS
type A a =
  | X
type B
type C
val x : a
external x = "x"
val f : A B -> A C -> A B
external f = "f"
val y : A B
let y = f X X

-- SUBSECTION pattern matching

-- TEST ill-typed overlap
-- FAILURE 2:5: mismatching types b and a
val f : Pair a b -> a
let f xy =
  match xy with
  | Pair x _ -> x
  | Pair _ y -> y

-- SUBSECTION type inferencer and checker

-- TEST annotation and inferred agree
-- SUCCESS
val myfold1 : (b -> a -> b) -> b -> List a -> b
let rec myfold1 f y0 xs =
  match xs with
  | Nil -> y0
  | Cons x xs -> myfold1 f (f y0 x) xs

-- TEST annotation and inferred disagree
-- SUCCESS
val myfold2 : (a -> b -> a) -> a -> List b -> a
let rec myfold2 f y0 xs =
  match xs with
  | Nil -> y0
  | Cons x xs -> myfold2 f (f y0 x) xs


-- SECTION pattern matcher

-- SUBSECTION successful

-- TEST nested list pattern
-- SUCCESS
val last : a -> List a -> a
let rec last x0 xs =
  match xs with
  | Nil                -> x0
  | Cons x Nil         -> x
  | Cons _ (Cons x xs) -> last x xs

-- TEST allowed let abuse
-- SUCCESS
val f : a -> a
let f x =
  match x with
  | y -> y

-- SUBSECTION failing

-- TEST forbidden let abuse
-- FAILURE 3:3: pattern match too simple, use a let binding instead
val f : a -> Option a
let f x =
  match Some x with
  | y -> y

-- TEST non-exhaustive top level
-- FAILURE 3:3: unmatched constructor: Second
val f : Choice a b -> a
let f xy =
  match xy with
  | First x -> x

-- TEST non-exhaustive nested
-- FAILURE 3:3: unmatched constructor: Second
val f : Pair (Choice a b) c -> a
let f xyz =
  match xyz with
  | Pair (First x) z -> x

-- TEST overlapping top level
-- FAILURE 3:3: overlapping patterns
val f : Pair a a -> a
let f xy =
  match xy with
  | Pair x _ -> x
  | Pair _ y -> y

-- TEST overlapping nested
-- FAILURE 3:3: overlapping patterns
val f : Pair (Option a) a -> a
let f xy =
  match xy with
  | Pair None     y -> y
  | Pair (Some x) _ -> x
  | Pair (Some _) y -> y

-- TEST constructor rule top level
-- FAILURE 3:3: cannot apply constructor rule
val f : a -> Option a -> a
let f x0 x_opt =
  match x_opt with
  | Some x -> x
  | _      -> x0

-- TEST constructor rule nested
-- FAILURE 3:3: cannot apply constructor rule
val f : a -> List (Option a) -> a
let rec f x0 ys =
  match ys with
  | Nil              -> x0
  | Cons (Some x) _  -> x
  | Cons _        ys -> f x0 ys
