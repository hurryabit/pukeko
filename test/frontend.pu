-- SECTION type resolver

-- SUBSECTION type cons

-- TEST unknown in type definition
-- FAILURE 2:5: unknown type constructor: Bad
data Typ =
  | Con Bad

-- TEST unknown in function declaration
-- FAILURE 1:1: unknown type constructor: Typ
bad : Typ

-- TEST duplicate in one type definition
-- FAILURE 2:6: duplicate type constructor: Typ
data Typ = | A
and  Typ = | B

-- TEST duplicate in two type definitions
-- FAILURE 1:6: duplicate type constructor: Int
data Int = | A

-- SUBSECTION data constructor

-- TEST unknown in expression
-- FAILURE 1:7: unknown data constructor: Con
bad = Con

-- TEST unknown in pattern
-- FAILURE 2:3: unknown data constructor: Con
f x =
  match x with
  | Con -> 1

-- TEST duplicate in one type
-- FAILURE 3:5: duplicate data constructor: Con
data Typ =
  | Con
  | Con

-- TEST duplicate in mutually recursive types
-- FAILURE 4:5: duplicate data constructor: Con
data Typ1 =
  | Con
and Typ2 =
  | Con

-- TEST duplicate in two types
-- FAILURE 2:5: duplicate data constructor: Nil
data Typ =
  | Nil


-- SECTION kind checker

-- SUBSECTION type definition

-- TEST underapplication in one definition
-- FAILURE 3:5: cannot unify kinds _3 -> * and *
data Typ1 a = | A
and Typ2 =
  | Con Typ1

-- TEST underapplication in recursive definition
-- FAILURE 2:5: cannot unify kinds _3 -> * and *
data Typ a b =
  | Con (Typ a)

-- TEST underapplication in two definitions
-- FAILURE 2:5: cannot unify kinds * -> * and *
data Typ =
  | Con List

-- TEST overapplication in one definition
-- FAILURE 3:5: cannot unify kinds * and _6 -> *
data Typ1 a = | A
and Typ2 a =
  | Con (Typ1 a a)

-- TEST overapplication in recursive definition
-- FAILURE 2:5: cannot unify kinds * and _4 -> *
data Typ a =
  | Con (Typ a a)

-- TEST overapplication in two definitions
-- FAILURE 2:5: cannot unify kinds * and _3 -> *
data Typ a =
  | Con (Int a)

-- TEST unbound type variable
-- FAILURE 2:5: unknown type variable: b
data Typ a =
  | Con b

-- XTEST repeated type variable
-- SUCCESS
data Typ a a =
  | Con a

-- TEST self application of type variable
-- FAILURE 2:5: occurs check
data Typ f =
  | Con (f f)

-- TEST type variable of kinds * and * -> *
-- FAILURE 2:5: cannot unify kinds * and _4 -> *
data Typ f a =
  | Con f (f a)

-- TEST type variable of kinds * -> * and * -> * -> *
-- FAILURE 2:5: cannot unify kinds _5 -> * and *
data Typ f a b =
  | Con (f a b) (f a)

-- TEST phantom type variable has kind *
-- FAILURE 6:5: cannot unify kinds * -> * and *
data Typ1 a =
  | Con1
and Typ2 a b =
  | Con2 (a b)
data Typ3 f a =
  | Con3 (Typ1 f) (Typ2 f a)


-- SUBSECTION function declaration

-- TEST underapplication
-- FAILURE 1:1: cannot unify kinds * -> * and *
bad : List
bad = abort

-- TEST overapplication
-- FAILURE 1:1: cannot unify kinds * and * -> *
bad : Unit Int
bad = abort


-- SECTION declaration/definition checker

-- SUBSECTION too many declarations

-- TEST duplicate declaration
-- FAILURE 2:1: duplicate declaration of function: f
f : a -> a
f : a -> a

-- TEST redeclaration
-- FAILURE 1:1: duplicate declaration of function: not
not : Bool -> Bool

-- TEST missing definition
-- FAILURE 1:1: declared but undefined function: f
f : a -> a

-- SUBSECTION duplicate definition

-- TEST two definitions far away
-- FAILURE 1:1: duplicate definition of function: not
not x = x

-- TEST two definitions next to each other
-- FAILURE 3:1: duplicate definition of function: f
f : a -> a
f x = x
f x = x

-- SUBSECTION definition of undeclared function

-- TEST definition
-- FAILURE 1:1: undeclared function: f
f x = x

-- TEST post declaration
-- FAILURE 1:1: undeclared function: f
f x = x
f : a -> a

-- TEST external
-- FAILURE 1:10: undeclared function: f
external f = "f"

-- SUBSECTION call of undeclared function

-- TEST one definition
-- FAILURE 2:7: unknown variable: g
f : x -> x
f a = g a

-- TEST recursive definition
-- FAILURE 2:7: unknown variable: g
f : x -> x
f a = g a

-- TEST post declaration
-- FAILURE 2:7: unknown variable: g
f : a -> a
f x = g x
g : a -> a

-- SUBSECTION call of undefined function

-- TEST call of other
-- FAILURE 2:1: declared but undefined function: g
f : a -> a
g : a -> a
f x = g x

-- SECTION type checker

-- SUBSECTION data constructor

-- TEST underapplication in expression
-- FAILURE 2:1: mismatching types Option and (->) _1
bad : Option a
bad = Some

-- TEST overapplication in expression
-- FAILURE 2:7: mismatching types Option and (->) _1
f : a -> Option a
f x = Some x x

-- TEST underapplication in pattern
-- FAILURE 3:3: data constructor 'Cons' expects 2 arguments
f : List a -> a
f x =
  match x with
  | Cons y -> y

-- TEST overapplication in pattern
-- FAILURE 3:3: data constructor 'Some' expects 1 arguments
f : Option a -> a
f x =
  match x with
  | Some y _ -> y

-- SUBSECTION unification

-- TEST type constructor vs type cons
-- FAILURE 2:1: mismatching types Unit and Int
bad : Unit
bad = 1

-- TEST type constructor vs arrow
-- FAILURE 2:1: mismatching types Option and (->) _1
bad : Option a
bad = fun y -> y

-- TEST arrow vs type cons
-- FAILURE 2:1: mismatching types a -> b and Unit
f : a -> b
f = Unit

-- TEST qvar vs qvar
-- FAILURE 2:1: mismatching types b and a
f : a -> b
f x = x

-- TEST qvar vs type cons
-- FAILURE 2:1: mismatching types a and Int
bad : a
bad = 1

-- TEST qvar vs arrow
-- FAILURE 2:1: mismatching types a and _1 -> _1
bad : a
bad = fun y -> y

-- TEST in type cons, 1
-- FAILURE 2:1: mismatching types b and a
f : Option a -> Option b
f x = x

-- TEST in type cons, 2
-- FAILURE 2:1: mismatching types c and b
f : Pair a b -> Pair a c
f x = x

-- TEST in lhs of arrow
-- FAILURE 2:1: mismatching types b and a
f : (a -> c) -> (b -> c)
f x = x

-- TEST in rhs of arrow
-- FAILURE 2:1: mismatching types c and b
f : (a -> b) -> (a -> c)
f x = x

-- TEST occurs check
-- FAILURE 2:7: '_3' occurs in List _3
bad : List a
bad = let rec x = Cons x Nil in x

-- TEST no overgeneralization
-- FAILURE 5:5: mismatching types Int and Bool
f : Int
f =
  let g x =
    let h y = x in
    if h True then 0 else h False
  in
  0


-- SUBSECTION misc

-- TEST function application unifies
-- FAILURE 4:1: mismatching types b and a
f : a -> a
external f = "f"
g : a -> b
g x = f x

-- TEST var instantiation
-- SUCCESS
type A = external
type B = external
x : a
external x = "x"
f : A -> B -> A
external f = "f"
y : A
y = f x x

-- TEST data constructor instantiation
-- SUCCESS
data A a =
  | X
type B = external
type C = external
x : a
external x = "x"
f : A B -> A C -> A B
external f = "f"
y : A B
y = f X X

-- SUBSECTION pattern matching

-- TEST ill-typed overlap
-- FAILURE 2:1: mismatching types b and a
f : Pair a b -> a
f xy =
  match xy with
  | Pair x _ -> x
  | Pair _ y -> y

-- SUBSECTION type inferencer and checker

-- TEST annotation and inferred agree
-- SUCCESS
myfold1 : (b -> a -> b) -> b -> List a -> b
myfold1 f y0 xs =
  match xs with
  | Nil -> y0
  | Cons x xs -> myfold1 f (f y0 x) xs

-- TEST annotation and inferred disagree
-- SUCCESS
myfold2 : (a -> b -> a) -> a -> List b -> a
myfold2 f y0 xs =
  match xs with
  | Nil -> y0
  | Cons x xs -> myfold2 f (f y0 x) xs


-- SECTION pattern matcher

-- SUBSECTION successful

-- TEST nested list pattern
-- SUCCESS
last : a -> List a -> a
last x0 xs =
  match xs with
  | Nil                -> x0
  | Cons x Nil         -> x
  | Cons _ (Cons x xs) -> last x xs

-- TEST allowed let abuse
-- FAILURE 3:3: pattern match too simple, use a let binding instead
f : a -> a
f x =
  match x with
  | y -> y

-- SUBSECTION failing

-- TEST forbidden let abuse
-- FAILURE 3:3: pattern match too simple, use a let binding instead
f : a -> Option a
f x =
  match Some x with
  | y -> y

-- TEST non-exhaustive top level
-- FAILURE 3:3: unmatched constructor: Second
f : Choice a b -> a
f xy =
  match xy with
  | First x -> x

-- TEST non-exhaustive nested
-- FAILURE 3:3: unmatched constructor: Second
f : Pair (Choice a b) c -> a
f xyz =
  match xyz with
  | Pair (First x) z -> x

-- TEST overlapping top level
-- FAILURE 3:3: overlapping patterns
f : Pair a a -> a
f xy =
  match xy with
  | Pair x _ -> x
  | Pair _ y -> y

-- TEST overlapping nested
-- FAILURE 3:3: overlapping patterns
f : Pair (Option a) a -> a
f xy =
  match xy with
  | Pair None     y -> y
  | Pair (Some x) _ -> x
  | Pair (Some _) y -> y

-- TEST constructor rule top level
-- FAILURE 3:3: cannot apply constructor rule
f : a -> Option a -> a
f x0 x_opt =
  match x_opt with
  | Some x -> x
  | _      -> x0

-- TEST constructor rule nested
-- FAILURE 3:3: cannot apply constructor rule
f : a -> List (Option a) -> a
f x0 ys =
  match ys with
  | Nil              -> x0
  | Cons (Some x) _  -> x
  | Cons _        ys -> f x0 ys
