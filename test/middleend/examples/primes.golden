data Unit =
       | Unit
data Bool =
       | False
       | True
data Pair a b =
       | Pair a b
data Option a =
       | None
       | Some a
data Choice a b =
       | First a
       | Second b
data Eq a =
       | .Eq (a -> a -> Bool)
data Ord a =
       | .Ord (Eq a) (a -> a -> Bool) (a -> a -> Bool) (a -> a -> Bool) (a -> a -> Bool)
data Monoid m =
       | .Monoid m (m -> m -> m)
data Ring a =
       | .Ring (a -> a) (a -> a -> a) (a -> a -> a) (a -> a -> a)
data Char
data Functor f =
       | .Functor (forall a b. (a -> b) -> f a -> f b)
data Foldable t =
       | .Foldable (forall a b. (a -> b -> b) -> b -> t a -> b) (forall a b. (b -> a -> b) -> b -> t a -> b)
data List a =
       | Nil
       | Cons a (List a)
data Monad m =
       | .Monad (Functor m) (forall a. a -> m a) (forall a b. m a -> (a -> m b) -> m b)
data World
data IO a = World -> Pair a World
external abort :: forall a. a = "abort"
external eq_int :: Int -> Int -> Bool = "eq"
external le_int :: Int -> Int -> Bool = "le"
external neg_int :: Int -> Int = "neg"
external add_int :: Int -> Int -> Int = "add"
external sub_int :: Int -> Int -> Int = "sub"
external mul_int :: Int -> Int -> Int = "mul"
external mod :: Int -> Int -> Int = "mod"
external seq :: forall a b. a -> b -> b = "seq"
external puti :: Int -> Unit = "puti"
external geti :: Unit -> Int = "geti"
ringInt :: Ring Int = .Ring @Int neg_int add_int sub_int mul_int
print :: Int -> IO Unit = io.L2 @Int @Unit puti
input :: IO Int = coerce @(_ -> IO) (io.L1 @Unit @Int geti Unit)
psums :: List Int -> List Int =
  let rec psums0 :: forall _10. Ring _10 -> _10 -> List _10 -> List _10 =
            psums.L1 psums0
  in
  psums0 @Int ringInt 0
sieve :: List Int -> List Int =
  \(ks :: List Int) ->
    case ks of
    | Nil -> abort @(List Int)
    | Cons p ks ->
      Cons
        @Int
        p
        (sieve
           (let p :: Int -> Bool = sieve.L1 p in
            let rec filter_p :: List Int -> List Int =
                      filter.L1 @Int p filter_p
            in
            filter_p ks))
primes :: List Int =
  Cons
    @Int
    2
    (Cons
       @Int
       3
       (sieve
          (psums
             (Cons
                @Int
                5
                (let xs :: List Int = Cons @Int 2 (Cons @Int 4 (Nil @Int)) in
                 let rec ys :: List Int =
                           let dict :: Monoid (List Int) =
                                 .Monoid
                                   @(List Int) (monoidList.empty @Int) (monoidList.append.L1 @Int)
                           in
                           (case dict of
                            | .Monoid _ append -> append)
                             xs ys
                 in
                 ys)))))
main :: IO Unit =
  coerce @(_ -> IO) (monadIO.bind.L1 @Int @Unit input main.L1)
monoidList.empty :: forall a. List a = Nil
monoidList.append.L1 :: forall a. List a -> List a -> List a =
  \@a (xs :: List a) (ys :: List a) ->
    foldableList.foldr.L1 @a @(List a) (Cons @a) ys xs
foldableList.foldr.L1 :: forall a b. (a -> b -> b) -> b -> List a -> b =
  \@a @b (f :: a -> b -> b) (y0 :: b) (xs :: List a) ->
    case xs of
    | Nil -> y0
    | Cons x xs -> f x (foldableList.foldr.L1 @a @b f y0 xs)
nth_exn.L1 :: forall a. List a -> Int -> a =
  \@a (xs :: List a) (n :: Int) ->
    case xs of
    | Nil -> abort @a
    | Cons x xs ->
      case le_int n 0 of
      | False -> nth_exn.L1 @a xs (sub_int n 1)
      | True -> x
monadIO.bind.L1 :: forall a b. IO a -> (a -> IO b) -> World -> Pair b World =
  \@a @b (mx :: IO a) (f :: a -> IO b) (world0 :: World) ->
    case coerce @(IO -> _) mx world0 of
    | Pair x world1 -> coerce @(IO -> _) (f x) world1
io.L1 :: forall a b. (a -> b) -> a -> World -> Pair b World =
  \@a @b (f :: a -> b) (x :: a) (world :: World) ->
    let y :: b = f x in
    seq @b @(Pair b World) y (Pair @b @World y world)
io.L2 :: forall a b. (a -> b) -> a -> IO b =
  \@a @b (f :: a -> b) (x :: a) ->
    coerce @(_ -> IO) (io.L1 @a @b f x)
psums.L1 :: (forall _10. Ring _10 -> _10 -> List _10 -> List _10) -> (forall _10. Ring _10 -> _10 -> List _10 -> List _10) =
  \(psums0 :: forall _10. Ring _10 -> _10 -> List _10 -> List _10) @_10 (ring._10 :: Ring _10) (n :: _10) (xs :: List _10) ->
    case xs of
    | Nil -> Nil @_10
    | Cons x xs ->
      let y :: _10 =
            (case ring._10 of
             | .Ring _ add _ _ -> add)
              x n
      in
      Cons @_10 y (psums0 @_10 ring._10 y xs)
filter.L1 :: forall a. (a -> Bool) -> (List a -> List a) -> List a -> List a =
  \@a (p :: a -> Bool) (filter_p :: List a -> List a) (xs :: List a) ->
    case xs of
    | Nil -> Nil @a
    | Cons x xs ->
      let ys :: List a = filter_p xs in
      case p x of
      | False -> ys
      | True -> Cons @a x ys
sieve.L1 :: Int -> Int -> Bool =
  \(p :: Int) (k :: Int) ->
    let x :: Int = mod k p in
    case eq_int x 0 of
    | False -> True
    | True -> False
main.L1 :: Int -> IO Unit =
  \(n :: Int) -> print (nth_exn.L1 @Int primes n)
================================================================================
asm abort
asm eq
asm le
asm neg
asm add
asm sub
asm mul
asm mod
asm seq
asm puti
asm geti
let ringInt = Pack{0,4} $neg $add $sub $mul
let print = @io.L2 $puti
let input = @io.L1 $geti Pack{0,0}
let psums =
  let rec psums0 = @psums.L1 psums0[1] in
  psums0[1] @ringInt 0
let sieve ks =
  match ks[1] with
  | {0} -> $abort
  | {1} p ks ->
    Pack{1,2} p[2] (@sieve let p = @sieve.L1 p[2] in
                           let rec filter_p = @filter.L1 p[2] filter_p[1] in
                           filter_p[1] ks[3])
let primes =
  Pack{1,2} 2 (Pack{1,2} 3 (@sieve (@psums (Pack{1,2} 5 let xs =
                                                              Pack{1,2} 2 (Pack{1,2} 4 Pack{0,0})
                                                        in
                                                        let rec ys =
                                                                  let dict =
                                                                        Pack{0,2} @monoidList.empty @monoidList.append.L1
                                                                  in
                                                                  (match dict[1] with
                                                                   | {0} _ append ->
                                                                     append[1]) xs[3] ys[2]
                                                        in
                                                        ys[1]))))
let main = @monadIO.bind.L1 @input @main.L1
let monoidList.empty = Pack{0,0}
let monoidList.append.L1 xs ys =
  @foldableList.foldr.L1 Pack{1,2} ys[1] xs[2]
let foldableList.foldr.L1 f y0 xs =
  match xs[1] with
  | {0} -> y0[2]
  | {1} x xs -> f[5] x[2] (@foldableList.foldr.L1 f[5] y0[4] xs[1])
let nth_exn.L1 xs n =
  match xs[2] with
  | {0} -> $abort
  | {1} x xs ->
    match $le n[3] 0 with
    | {0} -> @nth_exn.L1 xs[1] ($sub n[3] 1)
    | {1} -> x[2]
let monadIO.bind.L1 mx f world0 =
  match mx[3] world0[1] with
  | {0} x world1 -> (f[4] x[2]) world1[1]
let io.L1 f x world =
  let y = f[3] x[2] in
  $seq y[1] (Pack{0,2} y[1] world[2])
let io.L2 f x = @io.L1 f[2] x[1]
let psums.L1 psums0 ring._10 n xs =
  match xs[1] with
  | {0} -> Pack{0,0}
  | {1} x xs ->
    let y =
          (match ring._10[5] with
           | {0} _ add _ _ -> add[3]) x[2] n[4]
    in
    Pack{1,2} y[1] (psums0[7] ring._10[6] y[1] xs[2])
let filter.L1 p filter_p xs =
  match xs[1] with
  | {0} -> Pack{0,0}
  | {1} x xs ->
    let ys = filter_p[4] xs[1] in
    match p[6] x[3] with
    | {0} -> ys[1]
    | {1} -> Pack{1,2} x[3] ys[1]
let sieve.L1 p k =
  let x = $mod k[1] p[2] in
  match $eq x[1] 0 with
  | {0} -> Pack{1,0}
  | {1} -> Pack{0,0}
let main.L1 n = @print (@nth_exn.L1 @primes n[1])
