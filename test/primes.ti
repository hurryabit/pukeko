external abort : ∀a. a = "abort"
let not : Bool -> Bool =
      fun (x : Bool) ->
        match x with
        | True -> False
        | False -> True
let (&&) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> y
        | False -> False
let (||) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> True
        | False -> y
external neg : Int -> Int = "neg"
external (+) : Int -> Int -> Int = "add"
external (-) : Int -> Int -> Int = "sub"
external (*) : Int -> Int -> Int = "mul"
external (/) : Int -> Int -> Int = "div"
external (%) : Int -> Int -> Int = "mod"
external (==) : Int -> Int -> Bool = "eq"
external (!=) : Int -> Int -> Bool = "ne"
external (<) : Int -> Int -> Bool = "lt"
external (<=) : Int -> Int -> Bool = "le"
external (>=) : Int -> Int -> Bool = "ge"
external (>) : Int -> Int -> Bool = "gt"
let foldr : ∀a b. (a -> b -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : a -> b -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil -> y0
          | Cons x xs -> f x (foldr f y0 xs)
let foldl : ∀a b. (b -> a -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : b -> a -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil -> y0
          | Cons x xs -> foldl f (f y0 x) xs
let take : ∀a. Int -> List a -> List a =
      fun @a ->
        fun (n : Int) (xs : List a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False ->
            match xs with
            | Nil -> Nil @a
            | Cons x xs -> Cons @a x (take ((-) n 1) xs)
let nth : ∀a. List a -> Int -> a =
      fun @a ->
        fun (xs : List a) (n : Int) ->
          match xs with
          | Nil -> abort @a
          | Cons x xs ->
            match (<=) n 0 with
            | True -> x
            | False -> nth xs ((-) n 1)
let zip_with : ∀a b c. (a -> b -> c) -> List a -> List b -> List c =
      fun @a @b @c ->
        fun (f : a -> b -> c) (xs : List a) (ys : List b) ->
          match xs with
          | Nil -> Nil @c
          | Cons x xs ->
            match ys with
            | Nil -> Nil @c
            | Cons y ys -> Cons @c (f x y) (zip_with f xs ys)
let partition : ∀a. (a -> Bool) -> List a -> Pair (List a) (List a) =
      fun @a ->
        fun (p : a -> Bool) (xs : List a) ->
          let rec part_p : List a -> Pair (List a) (List a) =
                    fun (xs : List a) ->
                      match xs with
                      | Nil -> Pair @(List a) @(List a) (Nil @a) (Nil @a)
                      | Cons x xs ->
                        match part_p xs with
                        | Pair ys zs ->
                          match p x with
                          | True -> Pair @(List a) @(List a) (Cons @a x ys) zs
                          | False -> Pair @(List a) @(List a) ys (Cons @a x zs)
          in
          part_p xs
let append : ∀a. List a -> List a -> List a =
      fun @a ->
        fun (xs : List a) (ys : List a) ->
          match xs with
          | Nil -> ys
          | Cons x xs -> Cons @a x (append xs ys)
let concat : ∀a. List (List a) -> List a =
      fun @a -> foldr @(List a) @(List a) (append @a) (Nil @a)
let map : ∀a b. (a -> b) -> List a -> List b =
      fun @a @b ->
        fun (f : a -> b) (xs : List a) ->
          match xs with
          | Nil -> Nil @b
          | Cons x xs -> Cons @b (f x) (map f xs)
let concat_map : ∀a b. (b -> List a) -> List b -> List a =
      fun @a @b ->
        fun (f : b -> List a) (xs : List b) ->
          concat @a (map @b @(List a) f xs)
let length : ∀a. List a -> Int =
      fun @a -> foldr @a @Int (fun (x : a) (l : Int) -> (+) 1 l) 0
let replicate : ∀a. Int -> a -> List a =
      fun @a ->
        fun (n : Int) (x : a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False -> Cons @a x (replicate ((-) n 1) x)
let insert_tree : Int -> Tree Int -> Tree Int =
      fun (x : Int) (t : Tree Int) ->
        match t with
        | Leaf -> Branch @Int (Leaf @Int) x (Leaf @Int)
        | Branch l y r ->
          match (<=) x y with
          | True -> Branch @Int (insert_tree x l) y r
          | False -> Branch @Int l y (insert_tree x r)
let in_order : ∀a. Tree a -> List a =
      fun @a ->
        fun (t : Tree a) ->
          match t with
          | Leaf -> Nil @a
          | Branch l x r -> append @a (in_order l) (Cons @a x (in_order r))
external return : ∀a. a -> IO a = "return"
external print : Int -> IO Unit = "print"
external input : IO Int = "input"
external (>>=) : ∀a b. IO a -> (a -> IO b) -> IO b = "bind"
let (;) : ∀a b. IO b -> IO a -> IO a =
      fun @a @b ->
        fun (m1 : IO b) (m2 : IO a) -> (>>=) @b @a m1 (fun (x : b) -> m2)
let sequence_io : ∀a. List (IO a) -> IO (List a) =
      fun @a ->
        fun (ms : List (IO a)) ->
          match ms with
          | Nil -> return @(List a) (Nil @a)
          | Cons m ms ->
            (>>=) @a @(List a) m (fun (x : a) ->
                                    (>>=) @(List a) @(List a) (sequence_io ms) (fun (xs : List a) ->
                                                                                  return @(List a) (Cons @a x xs)))
let iter_io : ∀a. (a -> IO Unit) -> List a -> IO Unit =
      fun @a ->
        fun (f : a -> IO Unit) ->
          foldr @a @(IO Unit) (fun (x : a) (m : IO Unit) ->
                                 (;) @Unit (f x) m) (return @Unit Unit)
let print_list : List Int -> IO Unit = iter_io @Int print
let repeat : ∀a. List a -> List a =
      fun @a ->
        fun (xs : List a) ->
          let rec ys : List a = append @a xs ys in
          ys
let psums : List Int -> List Int =
      let rec psums0 : Int -> List Int -> List Int =
                fun (n : Int) (xs : List Int) ->
                  match xs with
                  | Nil -> Nil @Int
                  | Cons x xs ->
                    let y : Int = (+) x n in
                    Cons @Int y (psums0 y xs)
      in
      psums0 0
let filter : ∀a. (a -> Bool) -> List a -> List a =
      fun @a ->
        fun (p : a -> Bool) ->
          let rec filter_p : List a -> List a =
                    fun (xs : List a) ->
                      match xs with
                      | Nil -> Nil @a
                      | Cons x xs ->
                        let ys : List a = filter_p xs in
                        match p x with
                        | True -> Cons @a x ys
                        | False -> ys
          in
          filter_p
let sieve : List Int -> List Int =
      fun (ks : List Int) ->
        match ks with
        | Nil -> abort @(List Int)
        | Cons p ks ->
          Cons @Int p (sieve (filter @Int (fun (k : Int) ->
                                             (!=) ((%) k p) 0) ks))
let primes : List Int =
      Cons @Int 2 (Cons @Int 3 (sieve (psums (Cons @Int 5 (repeat @Int (Cons @Int 2 (Cons @Int 4 (Nil @Int))))))))
let main : IO Unit =
      (>>=) @Int @Unit input (fun (n : Int) -> print (nth @Int primes n))
