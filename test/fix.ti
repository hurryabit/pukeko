external abort : ∀a. a = "abort"
let not : Bool -> Bool =
      fun (x : Bool) ->
        match x with
        | True -> False
        | False -> True
let (&&) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> y
        | False -> False
let (||) : Bool -> Bool -> Bool =
      fun (x : Bool) (y : Bool) ->
        match x with
        | True -> True
        | False -> y
external neg : Int -> Int = "neg"
external (+) : Int -> Int -> Int = "add"
external (-) : Int -> Int -> Int = "sub"
external (*) : Int -> Int -> Int = "mul"
external (/) : Int -> Int -> Int = "div"
external (%) : Int -> Int -> Int = "mod"
external (==) : Int -> Int -> Bool = "eq"
external (!=) : Int -> Int -> Bool = "ne"
external (<) : Int -> Int -> Bool = "lt"
external (<=) : Int -> Int -> Bool = "le"
external (>=) : Int -> Int -> Bool = "ge"
external (>) : Int -> Int -> Bool = "gt"
let foldr : ∀a b. (a -> b -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : a -> b -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil -> y0
          | Cons x xs -> f x (foldr f y0 xs)
let foldl : ∀a b. (b -> a -> b) -> b -> List a -> b =
      fun @a @b ->
        fun (f : b -> a -> b) (y0 : b) (xs : List a) ->
          match xs with
          | Nil -> y0
          | Cons x xs -> foldl f (f y0 x) xs
let take : ∀a. Int -> List a -> List a =
      fun @a ->
        fun (n : Int) (xs : List a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False ->
            match xs with
            | Nil -> Nil @a
            | Cons x xs -> Cons @a x (take ((-) n 1) xs)
let nth : ∀a. List a -> Int -> a =
      fun @a ->
        fun (xs : List a) (n : Int) ->
          match xs with
          | Nil -> abort @a
          | Cons x xs ->
            match (<=) n 0 with
            | True -> x
            | False -> nth xs ((-) n 1)
let zip_with : ∀a b c. (a -> b -> c) -> List a -> List b -> List c =
      fun @a @b @c ->
        fun (f : a -> b -> c) (xs : List a) (ys : List b) ->
          match xs with
          | Nil -> Nil @c
          | Cons x xs ->
            match ys with
            | Nil -> Nil @c
            | Cons y ys -> Cons @c (f x y) (zip_with f xs ys)
let partition : ∀a. (a -> Bool) -> List a -> Pair (List a) (List a) =
      fun @a ->
        fun (p : a -> Bool) (xs : List a) ->
          let rec part_p : List a -> Pair (List a) (List a) =
                    fun (xs : List a) ->
                      match xs with
                      | Nil -> Pair @(List a) @(List a) (Nil @a) (Nil @a)
                      | Cons x xs ->
                        match part_p xs with
                        | Pair ys zs ->
                          match p x with
                          | True -> Pair @(List a) @(List a) (Cons @a x ys) zs
                          | False -> Pair @(List a) @(List a) ys (Cons @a x zs)
          in
          part_p xs
let append : ∀a. List a -> List a -> List a =
      fun @a ->
        fun (xs : List a) (ys : List a) ->
          match xs with
          | Nil -> ys
          | Cons x xs -> Cons @a x (append xs ys)
let concat : ∀a. List (List a) -> List a =
      fun @a -> foldr @(List a) @(List a) (append @a) (Nil @a)
let map : ∀a b. (a -> b) -> List a -> List b =
      fun @a @b ->
        fun (f : a -> b) (xs : List a) ->
          match xs with
          | Nil -> Nil @b
          | Cons x xs -> Cons @b (f x) (map f xs)
let concat_map : ∀a b. (b -> List a) -> List b -> List a =
      fun @a @b ->
        fun (f : b -> List a) (xs : List b) ->
          concat @a (map @b @(List a) f xs)
let length : ∀a. List a -> Int =
      fun @a -> foldr @a @Int (fun (x : a) (l : Int) -> (+) 1 l) 0
let replicate : ∀a. Int -> a -> List a =
      fun @a ->
        fun (n : Int) (x : a) ->
          match (<=) n 0 with
          | True -> Nil @a
          | False -> Cons @a x (replicate ((-) n 1) x)
let insert_tree : Int -> Tree Int -> Tree Int =
      fun (x : Int) (t : Tree Int) ->
        match t with
        | Leaf -> Branch @Int (Leaf @Int) x (Leaf @Int)
        | Branch l y r ->
          match (<=) x y with
          | True -> Branch @Int (insert_tree x l) y r
          | False -> Branch @Int l y (insert_tree x r)
let in_order : ∀a. Tree a -> List a =
      fun @a ->
        fun (t : Tree a) ->
          match t with
          | Leaf -> Nil @a
          | Branch l x r -> append @a (in_order l) (Cons @a x (in_order r))
external return : ∀a. a -> IO a = "return"
external print : Int -> IO Unit = "print"
external input : IO Int = "input"
external (>>=) : ∀a b. IO a -> (a -> IO b) -> IO b = "bind"
let (;) : ∀a b. IO b -> IO a -> IO a =
      fun @a @b ->
        fun (m1 : IO b) (m2 : IO a) -> (>>=) @b @a m1 (fun (x : b) -> m2)
let sequence_io : ∀a. List (IO a) -> IO (List a) =
      fun @a ->
        fun (ms : List (IO a)) ->
          match ms with
          | Nil -> return @(List a) (Nil @a)
          | Cons m ms ->
            (>>=) @a @(List a) m (fun (x : a) ->
                                    (>>=) @(List a) @(List a) (sequence_io ms) (fun (xs : List a) ->
                                                                                  return @(List a) (Cons @a x xs)))
let iter_io : ∀a. (a -> IO Unit) -> List a -> IO Unit =
      fun @a ->
        fun (f : a -> IO Unit) ->
          foldr @a @(IO Unit) (fun (x : a) (m : IO Unit) ->
                                 (;) @Unit (f x) m) (return @Unit Unit)
let print_list : List Int -> IO Unit = iter_io @Int print
let id : ∀a. a -> a = fun @a -> fun (x : a) -> x
let cata : ∀a b c. ((Fix a -> c) -> a (Fix a) -> b) -> (b -> c) -> Fix a -> c =
      fun @a @b @c ->
        fun (fmap : (Fix a -> c) -> a (Fix a) -> b) (f : b -> c) (x : Fix a) ->
          match x with
          | Fix y -> f (fmap (cata fmap f) y)
let ana : ∀a b c. ((a -> Fix b) -> c -> b (Fix b)) -> (a -> c) -> a -> Fix b =
      fun @a @b @c ->
        fun (fmap : (a -> Fix b) -> c -> b (Fix b)) (f : a -> c) (x : a) ->
          Fix @b (fmap (ana fmap f) (f x))
let mapFix : ∀a b c. (a -> (Fix b -> Fix c) -> b (Fix b) -> c (Fix c)) -> a -> Fix b -> Fix c =
      fun @a @b @c ->
        fun (bimap : a -> (Fix b -> Fix c) -> b (Fix b) -> c (Fix c)) (f : a) (x : Fix b) ->
          match x with
          | Fix y -> Fix @c (bimap f (mapFix bimap f) y)
let bimapListF : ∀a b c d. (a -> c) -> (b -> d) -> ListF a b -> ListF c d =
      fun @a @b @c @d ->
        fun (f : a -> c) (g : b -> d) (x : ListF a b) ->
          match x with
          | NilF -> NilF @c @d
          | ConsF y z -> ConsF @c @d (f y) (g z)
let mapFixList : ∀a b. (a -> b) -> Fix (ListF a) -> Fix (ListF b) =
      fun @a @b ->
        mapFix @a @b @ListF (bimapListF @a @b @(Fix (ListF a)) @(Fix (ListF b)))
let toList : ∀a. Fix (ListF a) -> List a =
      fun @a ->
        cata @(List a) @(ListF a) (bimapListF @a @a @(Fix (ListF a)) @(List a) (id @a)) (fun (x : ListF a (List a)) ->
                                                                                           match x with
                                                                                           | NilF ->
                                                                                             Nil @a
                                                                                           | ConsF y ys ->
                                                                                             Cons @a y ys)
let fromList : ∀a. List a -> Fix (ListF a) =
      fun @a ->
        ana @(List a) @(ListF a) (bimapListF @a @a @(List a) @(Fix (ListF a)) (id @a)) (fun (x : List a) ->
                                                                                          match x with
                                                                                          | Nil ->
                                                                                            NilF @a @(List a)
                                                                                          | Cons y ys ->
                                                                                            ConsF @a @(List a) y ys)
let main : IO Unit =
      (>>=) @Int @Unit input (fun (n : Int) ->
                                (>>=) @(List Int) @Unit (sequence_io @Int (replicate @(IO Int) n input)) (fun (xs : List Int) ->
                                                                                                            iter_io @Int print (toList @Int (mapFixList @Int @Int (fun (x : Int) ->
                                                                                                                                                                     (*) 2 x) (fromList @Int xs)))))
