-- SECTION type resolver

-- SUBSECTION type cons

-- TEST unknown in type definition
-- FAILURE (line 1, column 1): unknown type cons 'Bad'
type Typ =
  | Con Bad

-- TEST unknown in function declaration
-- FAILURE (line 1, column 1): unknown type cons 'Typ'
val bad : Typ

-- TEST duplicate in one type definition
-- FAILURE (line 1, column 1): duplicate type cons 'Typ'
type Typ
 and Typ

-- TEST duplicate in two type definitions
-- FAILURE (line 1, column 1): duplicate type cons 'Int'
type Int

-- SUBSECTION term cons

-- TEST unknown in expression
-- FAILURE (line 1, column 11): unknown term cons 'Con'
let bad = Con

-- TEST unknown in pattern
-- FAILURE (line 3, column 5): unknown term cons 'Con'
let f x =
  match x with
  | Con -> 1

-- TEST duplicate in one type
-- FAILURE (line 1, column 1): duplicate term cons 'Con'
type Typ =
  | Con
  | Con

-- TEST duplicate in mutually recursive types
-- FAILURE (line 1, column 1): duplicate term cons 'Con'
type Typ1 =
  | Con
and Typ2 =
  | Con

-- TEST duplicate in two types
-- FAILURE (line 1, column 1): duplicate term cons 'Nil'
type Typ =
  | Nil


-- SECTION kind checker

-- SUBSECTION type definition

-- TEST underapplication in one definition
-- FAILURE (line 1, column 1): type cons 'Typ1' expects 1 parameters
type Typ1 a
and Typ2 =
  | Con Typ1

-- TEST underapplication in recursive definition
-- FAILURE (line 1, column 1): type cons 'Typ' expects 2 parameters
type Typ a b =
  | Con (Typ a)

-- TEST underapplication in two definitions
-- FAILURE (line 1, column 1): type cons 'List' expects 1 parameters
type Typ =
  | Con List

-- TEST overapplication in one definition
-- FAILURE (line 1, column 1): type cons 'Typ1' expects 1 parameters
type Typ1 a
and Typ2 a =
  | Con (Typ1 a a)

-- TEST overapplication in recursive definition
-- FAILURE (line 1, column 1): type cons 'Typ' expects 1 parameters
type Typ a =
  | Con (Typ a a)

-- TEST overapplication in two definitions
-- FAILURE (line 1, column 1): type cons 'Int' expects 0 parameters
type Typ a =
  | Con (Int a)

-- TEST unbound type variable
-- FAILURE (line 1, column 1): unbound type vars in term cons 'Con'
type Typ a =
  | Con b

-- XTEST repeated type variable
-- FAILURE bla bla bla
type Typ a a =
  | Con a

-- SUBSECTION function declaration

-- TEST underapplication
-- FAILURE (line 1, column 1): type cons 'List' expects 1 parameters
val bad : List

-- TEST overapplication
-- FAILURE (line 1, column 1): type cons 'Unit' expects 0 parameters
val bad : Unit Int


-- SECTION declaration/definition checker

-- SUBSECTION too many declarations

-- TEST duplicate declaration
-- FAILURE (line 2, column 1): duplicate declaration of function 'f'
val f : a -> a
val f : a -> a

-- TEST redeclaration
-- FAILURE (line 1, column 1): duplicate declaration of function 'not'
val not : Bool -> Bool

-- XTEST missing definition
-- FAILURE
val f : a -> a

-- SUBSECTION duplicate definition

-- TEST two definitions
-- FAILURE (line 1, column 1): duplicate definition of function 'not'
let not x = x

-- TEST parallel definition
-- FAILURE (line 2, column 1): duplicate definition of function 'f'
val f : a -> a
let f x = x
and f x = x

-- SUBSECTION definition of undeclared function

-- TEST normal definition
-- FAILURE (line 1, column 1): undeclared function 'f'
let f x = x

-- TEST recursive definition
-- FAILURE (line 1, column 1): undeclared function 'f'
let rec f x = f x

-- TEST parallel definition
-- FAILURE (line 2, column 1): undeclared function 'g'
val f : a -> a
let f x = x
and g x = x

-- TEST mutually recursive definition
-- FAILURE (line 2, column 1): undeclared function 'g'
val f : a -> a
let rec f x = x
and g x = x

-- TEST post declaration
-- FAILURE (line 1, column 1): undeclared function 'f'
let f x = x
val f : a -> a

-- TEST external
-- FAILURE (line 1, column 1): undeclared function 'f'
external f = "f"

-- SUBSECTION call of undeclared function

-- TEST one definition
-- FAILURE (line 2, column 11): undeclared function 'g'
val f : x -> x
let f a = g a

-- TEST recursive definition
-- FAILURE (line 2, column 15): undeclared function 'g'
val f : x -> x
let rec f a = g a

-- TEST post declaration
-- FAILURE (line 2, column 11): undeclared function 'g'
val f : a -> a
let f x = g x
val g : a -> a

-- SUBSECTION call of undefined function

-- TEST call of other
-- FAILURE (line 3, column 11): undefined function 'g'
val f : a -> a
val g : a -> a
let f x = g x

-- TEST call of self
-- FAILURE (line 2, column 11): undefined function 'f'
val f : a -> a
let f x = f x

-- TEST parallel call
-- FAILURE (line 3, column 11): undefined function 'g'
val f : a -> a
val g : a -> a
let f x = g x
and g x = f x

-- SECTION type checker

-- SUBSECTION term cons

-- TEST underapplication in expression
-- FAILURE (line 2, column 1): mismatching types Option a and _3 -> Option _3
val bad : Option a
let bad = Some

-- TEST overapplication in expression
-- FAILURE (line 2, column 11): mismatching types Option _2 and _2 -> _4
val f : a -> Option a
let f x = Some x x

-- TEST underapplication in pattern
-- FAILURE (line 4, column 5): term cons 'Cons' expects 2 arguments
val f : List a -> a
let f x =
  match x with
  | Cons y -> y

-- TEST overapplication in pattern
-- FAILURE (line 4, column 5): term cons 'Some' expects 1 arguments
val f : Option a -> a
let f x =
  match x with
  | Some y _ -> y

-- SUBSECTION unification

-- TEST type cons vs type cons
-- FAILURE (line 2, column 1): mismatching types Unit and Int
val bad : Unit
let bad = 1

-- TEST type cons vs arrow
-- FAILURE (line 2, column 1): mismatching types Option a and _3 -> _3
val bad : Option a
let bad = fun y -> y

-- TEST arrow vs type cons
-- FAILURE (line 2, column 1): mismatching types a -> b and Unit
val f : a -> b
let f = Unit

-- TEST qvar vs qvar
-- FAILURE (line 2, column 1): mismatching types b and a
val f : a -> b
let f x = x

-- TEST qvar vs type cons
-- FAILURE (line 2, column 1): mismatching types a and Int
val bad : a
let bad = 1

-- TEST qvar vs arrow
-- FAILURE (line 2, column 1): mismatching types a and _3 -> _3
val bad : a
let bad = fun y -> y

-- TEST in type cons, 1
-- FAILURE (line 2, column 1): mismatching types b and a
val f : Option a -> Option b
let f x = x

-- TEST in type cons, 2
-- FAILURE (line 2, column 1): mismatching types c and b
val f : Pair a b -> Pair a c
let f x = x

-- TEST in lhs of arrow
-- FAILURE (line 2, column 1): mismatching types b and a
val f : (a -> c) -> (b -> c)
let f x = x

-- TEST in rhs of arrow
-- FAILURE (line 2, column 1): mismatching types c and b
val f : (a -> b) -> (a -> c)
let f x = x

-- TEST occurs check
-- FAILURE (line 2, column 9): '_3' occurs in List _3
val bad : List a
let rec bad = Cons bad Nil

-- SUBSECTION misc

-- TEST function application unifies
-- FAILURE (line 4, column 1): mismatching types b and a
val f : a -> a
external f = "f"
val g : a -> b
let g x = f x

-- TEST var instantiation
-- SUCCESS
type A
type B
val x : a
external x = "x"
val f : A -> B -> A
external f = "f"
val y : A
let y = f x x

-- TEST term cons instantiation
-- SUCCESS
type A a =
  | X
type B
type C
val x : a
external x = "x"
val f : A B -> A C -> A B
external f = "f"
val y : A B
let y = f X X
