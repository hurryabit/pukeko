-- SECTION type resolver

-- SUBSECTION type cons

-- TEST unknown in type definition
-- FAILURE (line 1, column 1): unknown type cons 'Bad'
type Typ =
  | Con Bad

-- TEST unknown in function declaration
-- FAILURE (line 1, column 1): unknown type cons 'Typ'
val bad : Typ

-- TEST duplicate in one type definition
-- FAILURE (line 1, column 1): duplicate type cons 'Typ'
type Typ
 and Typ

-- TEST duplicate in two type definitions
-- FAILURE (line 1, column 1): duplicate type cons 'Int'
type Int

-- SUBSECTION term cons

-- TEST unknown in expression
-- FAILURE (line 1, column 11): unknown term cons 'Con'
let bad = Con

-- TEST unknown in pattern
-- FAILURE (line 3, column 5): unknown term cons 'Con'
let f x =
  match x with
  | Con -> 1

-- TEST duplicate in one type
-- FAILURE (line 1, column 1): duplicate term cons 'Con'
type Typ =
  | Con
  | Con

-- TEST duplicate in mutually recursive types
-- FAILURE (line 1, column 1): duplicate term cons 'Con'
type Typ1 =
  | Con
and Typ2 =
  | Con

-- TEST duplicate in two types
-- FAILURE (line 1, column 1): duplicate term cons 'Nil'
type Typ =
  | Nil


-- SECTION kind checker

-- SUBSECTION type definition

-- TEST underapplication in one definition
-- FAILURE (line 1, column 1): cannot unify kinds _251 -> * and *
type Typ1 a
and Typ2 =
  | Con Typ1

-- TEST underapplication in recursive definition
-- FAILURE (line 1, column 1): cannot unify kinds _251 -> * and *
type Typ a b =
  | Con (Typ a)

-- TEST underapplication in two definitions
-- FAILURE (line 1, column 1): cannot unify kinds * -> * and *
type Typ =
  | Con List

-- TEST overapplication in one definition
-- FAILURE (line 1, column 1): cannot unify kinds * and _254 -> *
type Typ1 a
and Typ2 a =
  | Con (Typ1 a a)

-- TEST overapplication in recursive definition
-- FAILURE (line 1, column 1): cannot unify kinds * and _252 -> *
type Typ a =
  | Con (Typ a a)

-- TEST overapplication in two definitions
-- FAILURE (line 1, column 1): cannot unify kinds * and _251 -> *
type Typ a =
  | Con (Int a)

-- TEST unbound type variable
-- FAILURE (line 1, column 1): unknown type variable 'b'
type Typ a =
  | Con b

-- XTEST repeated type variable
-- FAILURE bla bla bla
type Typ a a =
  | Con a

-- TEST self application of type variable
-- FAILURE (line 1, column 1): occurs check
type Typ f =
  | Con (f f)

-- TEST type variable of kinds * and * -> *
-- FAILURE (line 1, column 1): cannot unify kinds * and _252 -> *
type Typ f a =
  | Con f (f a)

-- TEST type variable of kinds * -> * and * -> * -> *
-- FAILURE (line 1, column 1): cannot unify kinds _253 -> * and *
type Typ f a b =
  | Con (f a b) (f a)

-- TEST phantom type variable has kind *
-- FAILURE (line 5, column 1): cannot unify kinds * -> * and *
type Typ1 a =
  | Con1
and Typ2 a b =
  | Con2 (a b)
type Typ3 f a =
  | Con3 (Typ1 f) (Typ2 f a)


-- SUBSECTION function declaration

-- TEST underapplication
-- FAILURE (line 1, column 1): cannot unify kinds * -> * and *
val bad : List
let bad = abort

-- TEST overapplication
-- FAILURE (line 1, column 1): cannot unify kinds * and * -> *
val bad : Unit Int
let bad = abort


-- SECTION declaration/definition checker

-- SUBSECTION too many declarations

-- TEST duplicate declaration
-- FAILURE (line 2, column 1): duplicate declaration of function 'f'
val f : a -> a
val f : a -> a

-- TEST redeclaration
-- FAILURE (line 1, column 1): duplicate declaration of function 'not'
val not : Bool -> Bool

-- TEST missing definition
-- FAILURE (line 1, column 1): declared but undefined function 'f'
val f : a -> a

-- SUBSECTION duplicate definition

-- TEST two definitions
-- FAILURE (line 1, column 5): duplicate definition of function 'not'
let not x = x

-- TEST parallel definition
-- FAILURE (line 3, column 5): duplicate definition of function 'f'
val f : a -> a
let f x = x
and f x = x

-- TEST mutually recursive definition
-- FAILURE (line 3, column 5): duplicate definition of function 'f'
val f : a -> a
let rec f x = x
and f x = x

-- SUBSECTION definition of undeclared function

-- TEST normal definition
-- FAILURE (line 1, column 5): undeclared function 'f'
let f x = x

-- TEST recursive definition
-- FAILURE (line 1, column 9): undeclared function 'f'
let rec f x = f x

-- TEST parallel definition
-- FAILURE (line 3, column 5): undeclared function 'g'
val f : a -> a
let f x = x
and g x = x

-- TEST mutually recursive definition
-- FAILURE (line 3, column 5): undeclared function 'g'
val f : a -> a
let rec f x = x
and g x = x

-- TEST post declaration
-- FAILURE (line 1, column 5): undeclared function 'f'
let f x = x
val f : a -> a

-- TEST external
-- FAILURE (line 1, column 1): undeclared function 'f'
external f = "f"

-- SUBSECTION call of undeclared function

-- TEST one definition
-- FAILURE (line 2, column 11): undefined function 'g'
val f : x -> x
let f a = g a

-- TEST recursive definition
-- FAILURE (line 2, column 15): undefined function 'g'
val f : x -> x
let rec f a = g a

-- TEST post declaration
-- FAILURE (line 2, column 11): undefined function 'g'
val f : a -> a
let f x = g x
val g : a -> a

-- SUBSECTION call of undefined function

-- TEST call of other
-- FAILURE (line 3, column 11): undefined function 'g'
val f : a -> a
val g : a -> a
let f x = g x

-- TEST call of self
-- FAILURE (line 2, column 11): undefined function 'f'
val f : a -> a
let f x = f x

-- TEST backward call in parallel
-- FAILURE (line 4, column 11): undefined function 'f'
val f : a -> a
val g : a -> a
let f x = x
and g x = f x

-- TEST forward call in parallel
-- FAILURE (line 3, column 11): undefined function 'g'
val f : a -> a
val g : a -> a
let f x = g x
and g x = x

-- SECTION type checker

-- SUBSECTION term cons

-- TEST underapplication in expression
-- FAILURE (line 2, column 5): mismatching types Option and (->) _2
val bad : Option a
let bad = Some

-- TEST overapplication in expression
-- FAILURE (line 2, column 11): mismatching types Option and (->) _1
val f : a -> Option a
let f x = Some x x

-- TEST underapplication in pattern
-- FAILURE (line 4, column 5): term cons 'Cons' expects 2 arguments
val f : List a -> a
let f x =
  match x with
  | Cons y -> y

-- TEST overapplication in pattern
-- FAILURE (line 4, column 5): term cons 'Some' expects 1 arguments
val f : Option a -> a
let f x =
  match x with
  | Some y _ -> y

-- SUBSECTION unification

-- TEST type cons vs type cons
-- FAILURE (line 2, column 5): mismatching types Unit and Int
val bad : Unit
let bad = 1

-- TEST type cons vs arrow
-- FAILURE (line 2, column 5): mismatching types Option and (->) _2
val bad : Option a
let bad = fun y -> y

-- TEST arrow vs type cons
-- FAILURE (line 2, column 5): mismatching types a -> b and Unit
val f : a -> b
let f = Unit

-- TEST qvar vs qvar
-- FAILURE (line 2, column 5): mismatching types b and a
val f : a -> b
let f x = x

-- TEST qvar vs type cons
-- FAILURE (line 2, column 5): mismatching types a and Int
val bad : a
let bad = 1

-- TEST qvar vs arrow
-- FAILURE (line 2, column 5): mismatching types a and _2 -> _2
val bad : a
let bad = fun y -> y

-- TEST in type cons, 1
-- FAILURE (line 2, column 5): mismatching types b and a
val f : Option a -> Option b
let f x = x

-- TEST in type cons, 2
-- FAILURE (line 2, column 5): mismatching types c and b
val f : Pair a b -> Pair a c
let f x = x

-- TEST in lhs of arrow
-- FAILURE (line 2, column 5): mismatching types b and a
val f : (a -> c) -> (b -> c)
let f x = x

-- TEST in rhs of arrow
-- FAILURE (line 2, column 5): mismatching types c and b
val f : (a -> b) -> (a -> c)
let f x = x

-- TEST occurs check
-- FAILURE (line 2, column 15): '_3' occurs in List _3
val bad : List a
let rec bad = Cons bad Nil

-- SUBSECTION misc

-- TEST function application unifies
-- FAILURE (line 4, column 5): mismatching types b and a
val f : a -> a
external f = "f"
val g : a -> b
let g x = f x

-- TEST var instantiation
-- SUCCESS
type A
type B
val x : a
external x = "x"
val f : A -> B -> A
external f = "f"
val y : A
let y = f x x

-- TEST term cons instantiation
-- SUCCESS
type A a =
  | X
type B
type C
val x : a
external x = "x"
val f : A B -> A C -> A B
external f = "f"
val y : A B
let y = f X X

-- SUBSECTION pattern matching

-- TEST ill-typed overlap
-- FAILURE (line 2, column 5): mismatching types b and a
val f : Pair a b -> a
let f xy =
  match xy with
  | Pair x _ -> x
  | Pair _ y -> y

-- SUBSECTION type inferencer and checker

-- TEST annotation and inferred agree
-- SUCCESS
val myfold1 : (b -> a -> b) -> b -> List a -> b
let rec myfold1 f y0 xs =
  match xs with
  | Nil -> y0
  | Cons x xs -> myfold1 f (f y0 x) xs

-- TEST annotation and inferred disagree
-- FAILURE (line 5, column 26): expected type a -> b -> a, but found type b -> a -> b
val myfold2 : (a -> b -> a) -> a -> List b -> a
let rec myfold2 f y0 xs =
  match xs with
  | Nil -> y0
  | Cons x xs -> myfold2 f (f y0 x) xs


-- SECTION pattern matcher

-- SUBSECTION successful

-- TEST nested list pattern
-- SUCCESS
val last : a -> List a -> a
let rec last x0 xs =
  match xs with
  | Nil                -> x0
  | Cons x Nil         -> x
  | Cons _ (Cons x xs) -> last x xs

-- TEST allowed let abuse
-- SUCCESS
val f : a -> a
let f x =
  match x with
  | y -> y

-- SUBSECTION failing

-- TEST forbidden let abuse
-- FAILURE (line 3, column 3): pattern match too simple, use a let binding instead
val f : a -> Option a
let f x =
  match Some x with
  | y -> y

-- TEST non-exhaustive top level
-- FAILURE (line 3, column 3): unmatched constructor 'Second'
val f : Choice a b -> a
let f xy =
  match xy with
  | First x -> x

-- TEST non-exhaustive nested
-- FAILURE (line 3, column 3): unmatched constructor 'Second'
val f : Pair (Choice a b) c -> a
let f xyz =
  match xyz with
  | Pair (First x) z -> x

-- TEST overlapping top level
-- FAILURE (line 3, column 3): overlapping patterns
val f : Pair a a -> a
let f xy =
  match xy with
  | Pair x _ -> x
  | Pair _ y -> y

-- TEST overlapping nested
-- FAILURE (line 3, column 3): overlapping patterns
val f : Pair (Option a) a -> a
let f xy =
  match xy with
  | Pair None     y -> y
  | Pair (Some x) _ -> x
  | Pair (Some _) y -> y

-- TEST constructor rule top level
-- FAILURE (line 3, column 3): cannot apply constructor rule
val f : a -> Option a -> a
let f x0 x_opt =
  match x_opt with
  | Some x -> x
  | _      -> x0

-- TEST constructor rule nested
-- FAILURE (line 3, column 3): cannot apply constructor rule
val f : a -> List (Option a) -> a
let rec f x0 ys =
  match ys with
  | Nil              -> x0
  | Cons (Some x) _  -> x
  | Cons _        ys -> f x0 ys
