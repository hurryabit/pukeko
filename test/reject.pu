-- SECTION type resolver

-- SUBSECTION type cons

-- TEST unknown in type definition
-- FAILURE (line 1, column 1): unknown type cons 'B'
type A =
  | X B

-- TEST unknown in function declaration
-- FAILURE (line 1, column 1): unknown type cons 'A'
val x : A

-- TEST duplicate in one type definition
-- FAILURE (line 1, column 1): duplicate type cons 'A'
type A
 and A

-- TEST duplicate in two type definitions
-- FAILURE (line 2, column 1): duplicate type cons 'A'
type A
type A

-- SUBSECTION term cons

-- TEST unknown in expression
-- FAILURE (line 1, column 9): unknown term cons 'X'
let x = X

-- TEST unknown in pattern
-- FAILURE (line 3, column 3): unknown term cons 'X'
let f x =
  match x with
  | X -> x

-- TEST duplicate in one type
-- FAILURE (line 1, column 1): duplicate term cons 'X'
type A =
  | X
  | X

-- TEST duplicate in mutually recursive types
-- FAILURE (line 1, column 1): duplicate term cons 'X'
type A =
  | X
and B =
  | X

-- TEST duplicate in two types
-- FAILURE (line 3, column 1): duplicate term cons 'X'
type A =
  | X
type B =
  | X


-- SECTION kind checker

-- SUBSECTION type definition

-- TEST underapplication in one definition
-- FAILURE (line 1, column 1): type cons 'A' expects 1 parameters
type A a =
  | X
and B =
  | Y A

-- TEST underapplication in recursive definition
-- FAILURE (line 1, column 1): type cons 'A' expects 2 parameters
type A a b =
  | X (A a)

-- TEST underapplication in two definitions
-- FAILURE (line 3, column 1): type cons 'A' expects 1 parameters
type A a =
  | X
type B =
  | Y A

-- TEST overapplication in one definition
-- FAILURE (line 1, column 1): type cons 'A' expects 1 parameters
type A a =
  | X
and B a b =
  | Y (A a b)

-- TEST overapplication in recursive definition
-- FAILURE (line 1, column 1): type cons 'A' expects 1 parameters
type A a =
  | X (A a a)

-- TEST overapplication in two definitions
-- FAILURE (line 3, column 1): type cons 'A' expects 1 parameters
type A a =
  | X
type B a b =
  | Y (A a b)

-- TEST unbound type variable
-- FAILURE (line 1, column 1): unbound type vars in term cons 'X'
type A a =
  | X b

-- XTEST repeated type variable
-- FAILURE bla bla bla
type A a a =
  | X a

-- SUBSECTION function declaration

-- TEST underapplication
-- FAILURE (line 2, column 1): type cons 'A' expects 1 parameters
type A a
val x : A

-- TEST overapplication
-- FAILURE (line 2, column 1): type cons 'A' expects 1 parameters
type A a
val x : A a b


-- SECTION declaration/definition checker

-- SUBSECTION too many declarations

-- TEST duplicate declaration
-- FAILURE (line 2, column 1): duplicate declaration of function 'f'
val f : a -> a
val f : a -> a

-- TEST redeclaration
-- FAILURE (line 3, column 1): duplicate declaration of function 'f'
val f : a -> a
let f x = x
val f : a -> a

-- XTEST missing definition
-- FAILURE
val f : a -> a

-- SUBSECTION duplicate definition

-- TEST two definitions
-- FAILURE (line 3, column 1): duplicate definition of function 'f'
val f : a -> a
let f x = x
let f x = x

-- TEST parallel definition
-- FAILURE (line 2, column 1): duplicate definition of function 'f'
val f : a -> a
let f x = x
and f x = x

-- TEST with interruption
-- FAILURE (line 5, column 1): duplicate definition of function 'f'
val f : a -> a
let f x = x
val g : a -> a
let g x = x
let f x = x

-- TEST external and definition
-- FAILURE (line 3, column 1): duplicate definition of function 'f'
val f : a -> a
external f = "f"
let f x = x

-- TEST definition and external
-- FAILURE (line 3, column 1): duplicate definition of function 'f'
val f : a -> a
let f x = x
external f = "f"

-- TEST external and external
-- FAILURE (line 3, column 1): duplicate definition of function 'f'
val f : a -> a
external f = "f"
external f = "f"

-- SUBSECTION definition of undeclared function

-- TEST one definition
-- FAILURE (line 1, column 1): undeclared function 'f'
let f x = x

-- TEST recursive definition
-- FAILURE (line 1, column 1): undeclared function 'f'
let rec f x = f x

-- TEST two definitions
-- FAILURE (line 3, column 1): undeclared function 'g'
val f : a -> a
let f x = x
let g x = x

-- TEST parallel definition
-- FAILURE (line 2, column 1): undeclared function 'g'
val f : a -> a
let f x = x
and g x = x

-- TEST mutually recursive definition
-- FAILURE (line 2, column 1): undeclared function 'g'
val f : a -> a
let rec f x = x
and g x = x

-- TEST post declaration
-- FAILURE (line 1, column 1): undeclared function 'f'
let f x = x
val f : a -> a

-- TEST external
-- FAILURE (line 1, column 1): undeclared function 'f'
external f = "f"

-- SUBSECTION call of undeclared function

-- TEST one definition
-- FAILURE (line 2, column 11): undeclared function 'g'
val f : x -> x
let f a = g a

-- TEST recursive definition
-- FAILURE (line 2, column 15): undeclared function 'g'
val f : x -> x
let rec f a = g a

-- TEST post declaration
-- FAILURE (line 2, column 11): undeclared function 'g'
val f : a -> a
let f x = g x
val g : a -> a

-- SUBSECTION call of undefined function

-- TEST call of other
-- FAILURE (line 3, column 11): undefined function 'g'
val f : a -> a
val g : a -> a
let f x = g x

-- TEST call of self
-- FAILURE (line 2, column 11): undefined function 'f'
val f : a -> a
let f x = f x

-- TEST parallel call
-- FAILURE (line 3, column 11): undefined function 'g'
val f : a -> a
val g : a -> a
let f x = g x
and g x = f x

-- SECTION type checker

-- SUBSECTION term cons

-- TEST underapplication in expression
-- FAILURE (line 4, column 1): mismatching types A a and _3 -> A _3
type A a =
  | X a
val x : A a
let x = X

-- TEST overapplication in expression
-- FAILURE (line 4, column 11): mismatching types A _2 and _2 -> _4
type A a =
  | X a
val f : a -> A a
let f x = X x x

-- TEST underapplication in pattern
-- FAILURE (line 6, column 3): term cons 'X' expects 2 arguments
type A a =
  | X a a
val f : A a -> a
let f x =
  match x with
  | X y -> y

-- TEST overapplication in pattern
-- FAILURE (line 6, column 3): term cons 'X' expects 1 arguments
type A a =
  | X a
val f : A a -> a
let f x =
  match x with
  | X y _ -> y

-- SUBSECTION unification

-- TEST type cons vs type cons
-- FAILURE (line 5, column 1): mismatching types A and B
type A
type B =
  | Y
val x : A
let x = Y

-- TEST type cons vs arrow
-- FAILURE (line 3, column 1): mismatching types A a and _3 -> _3
type A a
val x : A a
let x = fun y -> y

-- TEST arrow vs type cons
-- FAILURE (line 4, column 1): mismatching types a -> b and A
type A =
  | X
val f : a -> b
let f = X

-- TEST qvar vs qvar
-- FAILURE (line 2, column 1): mismatching types b and a
val f : a -> b
let f x = x

-- TEST qvar vs type cons
-- FAILURE (line 4, column 1): mismatching types a and A
type A =
  | X
val x : a
let x = X

-- TEST qvar vs arrow
-- FAILURE (line 2, column 1): mismatching types a and _3 -> _3
val x : a
let x = fun y -> y

-- TEST in type cons, 1
-- FAILURE (line 3, column 1): mismatching types b and a
type A a
val f : A a -> A b
let f x = x

-- TEST in type cons, 2
-- FAILURE (line 3, column 1): mismatching types c and b
type A a b
val f : A a b -> A a c
let f x = x

-- TEST in lhs of arrow
-- FAILURE (line 2, column 1): mismatching types b and a
val f : (a -> c) -> (b -> c)
let f x = x

-- TEST in rhs of arrow
-- FAILURE (line 2, column 1): mismatching types c and b
val f : (a -> b) -> (a -> c)
let f x = x

-- TEST occurs check
-- FAILURE (line 4, column 9): '_1' occurs in A _1
type A a =
  | X a
val x : A a
let rec x = X x

-- SUBSECTION misc

-- TEST function application unifies
-- FAILURE (line 4, column 1): mismatching types b and a
val f : a -> a
external f = "f"
val g : a -> b
let g x = f x

-- TEST var instantiation
-- SUCCESS
type A
type B
val x : a
external x = "x"
val f : A -> B -> A
external f = "f"
val y : A
let y = f x x

-- TEST term cons instantiation
-- SUCCESS
type A a =
  | X
type B
type C
val x : a
external x = "x"
val f : A B -> A C -> A B
external f = "f"
val y : A B
let y = f X X
