{-# LANGUAGE TemplateHaskell #-}
module CoreLang.GMachine.Compiler
  ( compile
  , Program
  )
  where

import Control.Monad.Except
import Control.Monad.Reader hiding (asks, local)
import Control.Monad.Writer
import Data.Label.Derive
import Data.Label.Monadic
import Data.Map (Map)
import Data.Set (Set)

import qualified Data.Map as Map
import qualified Data.Set as Set

import CoreLang.GMachine.GCode
import CoreLang.Language.Syntax

import qualified  CoreLang.GMachine.Builtins as Builtins

data Context = MkContext
  { _offsets :: Map Ident Int
  , _depth   :: Int
  }
mkLabels [''Context]

newtype CC a = CC { unCC :: ExceptT String (ReaderT Context (Writer [Inst])) a }
  deriving ( Functor, Applicative, Monad
           , MonadError String
           , MonadReader Context
           , MonadWriter [Inst]
           )

compile :: MonadError String m => Expr () -> m Program
compile expr =
  case expr of
    Let { _isrec = True, _defns, _body = Var { _ident } } -> do
      let _main = Name (unIdent _ident)
      globals <- mapM compileDefn (Builtins.uncompiled ++ _defns)
      let all_globals = Builtins.compiled ++ globals
          name_to_global =
            Map.fromList $ map (\global -> (_name global, global)) all_globals
          deps name =
            case Map.lookup name name_to_global of
              Nothing     -> throwError $ "Unknown global: " ++ unName name
              Just global -> return $ dependencies global
      reachable_names <- saturate deps _main
      let _globals =
            filter (\global -> _name global `Set.member` reachable_names) all_globals
      return $ MkProgram { _globals, _main }
          -- [ PUSHGLOBAL main
          -- , EVAL
          -- , PRINT
          -- , EXIT
          -- ]
    _ -> throwError "Expression is not generated by lambda lifter."


compileDefn :: MonadError String m => Defn a -> m Global
compileDefn MkDefn{ _patn = MkPatn{ _ident }, _expr } = do
  let (patns, body) =
        case _expr of
          Lam { _patns, _body } -> (_patns, _body)
          _                     -> ([]    , _expr)
      n = length patns
      (idents, _) = unzipPatns patns
      context = MkContext
        { _offsets = Map.fromList (zip idents [n, n-1 ..])
        , _depth   = n
        }
      (res, code) = runWriter (runReaderT (runExceptT (unCC $ ccExpr body)) context)
  case res of
    Left error -> throwError error
    Right ()   -> do
      let _name  = name _ident
          _arity = n
          _code  = [GLOBSTART _name _arity] ++ code ++ [UPDATE (n+1), POP n, UNWIND]
      return $ MkGlobal { _name, _arity, _code }


ccExpr :: Expr a -> CC ()
ccExpr expr =
  case expr of
    Var { _ident } -> do
      MkContext { _offsets, _depth } <- ask
      case Map.lookup _ident _offsets of
        Nothing     -> tell [PUSHGLOBAL (name _ident)]
        Just offset -> tell [PUSH (_depth - offset)]
    Num { _int } -> tell [PUSHINT _int]
    Ap { _fun, _arg } -> do
      ccExpr _arg
      local depth succ $ ccExpr _fun
      tell [MKAP]
    ApOp { _annot, _op, _arg1, _arg2 } -> ccExpr $
      Ap { _annot
         , _fun = Ap { _annot
                     , _fun = Var { _annot, _ident = _op }
                     , _arg = _arg1 }
         , _arg = _arg2 }
    Lam { } -> throwError "All lambdas should be lifted by now"
    Let { _isrec = False, _defns, _body } -> do
      let n = length _defns
          (idents, _, rhss) = unzipDefns3 _defns
      zipWithM_ (\rhs k -> local depth (+k) $ ccExpr rhs) rhss [0 ..]
      localDecls idents n $ ccExpr _body
      tell [SLIDE n]
    Let { _isrec = True, _defns, _body } -> do
      let n = length _defns
          (idents, _, rhss) = unzipDefns3 _defns
      tell [ALLOC n]
      localDecls idents n $ do
        zipWithM_ (\rhs k -> ccExpr rhs >> tell [UPDATE (n-k)]) rhss [0 ..]
        ccExpr _body
      tell [SLIDE n]
    Pack { } -> throwError "Constructors are not supported yet"
    If { _annot, _cond, _then, _else } -> ccExpr $
      Ap { _annot
         , _fun = Ap { _annot
                     , _fun = Ap { _annot
                                 , _fun = Var { _annot, _ident = MkIdent "if" }
                                 , _arg = _cond }
                     , _arg = _then }
         , _arg = _else }

localDecls :: [Ident] -> Int -> CC a -> CC a
localDecls idents n cc = do
  d <- asks depth
  let offs = Map.fromList (zip idents [d+1 ..])
  local offsets (Map.union offs) $ local depth (+n) $ cc

name :: Ident -> Name
name ident = Name (unIdent ident)


saturate :: (Monad m, Ord a) => (a -> m (Set a)) -> a -> m (Set a)
saturate f x0 = run [x0] Set.empty
  where
    run []     visited = return visited
    run (x:xs) visited
      | x `Set.member` visited = run xs visited
      | otherwise              = do
          ys <- f x
          run (Set.toList ys ++ xs) (Set.insert x visited)
