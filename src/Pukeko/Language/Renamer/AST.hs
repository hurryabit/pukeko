-- | AST generated by the introduction of de Bruijn indices.
module Pukeko.Language.Renamer.AST
  ( TypeCon
  , ExprCon
  , Module
  , TopLevel (..)
  , Defn
  , Expr (..)
  , Altn
  , Patn
  , abstract
  , (//)
  )
where

import           Control.Lens
import           Pukeko.Language.Base.AST
import           Pukeko.Language.Parser.AST (TypeCon, ExprCon)
import qualified Pukeko.Language.Ident      as Id
import qualified Pukeko.Language.Type       as Ty

type Module = [TopLevel]

data TopLevel
  =           TypDef Pos [Ty.ADT TypeCon]
  |           Val    Pos Id.EVar (Ty.Type TypeCon Ty.Closed)
  | forall n. TopLet Pos (Vector n (Defn Id.EVar))
  | forall n. TopRec Pos (Vector n (Defn (FinScope n Id.EVar)))
  |           Asm    Pos Id.EVar String

type Defn = StdDefn Expr

data Expr v
  =           Var Pos v
  |           Con Pos ExprCon
  |           Num Pos Int
  |           App Pos (Expr v) [Expr v]
  -- |           If  Pos (Expr v) (Expr v) (Expr v)
  |           Mat Pos (Expr v) [Altn v]
  | forall n. Lam Pos (Vector n Bind)                  (Expr (FinScope n v))
  | forall n. Let Pos (Vector n (Defn v))              (Expr (FinScope n v))
  | forall n. Rec Pos (Vector n (Defn (FinScope n v))) (Expr (FinScope n v))

type Altn = StdAltn ExprCon Expr

type Patn = StdPatn ExprCon

-- * Functions

-- | Abstract all variables which are mapped to @Just@.
abstract :: (v -> Maybe (i, Id.EVar)) -> Expr v -> Expr (Scope i v)
abstract f = fmap (match f)
  where
    match :: (v -> Maybe (i, Id.EVar)) -> v -> Scope i v
    match f v = maybe (Free v) (uncurry bound) (f v)

-- | Replace subexpressions.
(//) :: Expr v -> (Pos -> v -> Expr w) -> Expr w
expr // f = case expr of
  Var w x       -> f w x
  Con w c       -> Con w c
  Num w n       -> Num w n
  App w t  us   -> App w (t // f) (map (// f) us)
  -- If  w t  u  v -> If  w (t // f) (u // f) (v // f)
  Mat w t  as   -> Mat w (t // f) (map (mapAltnRhs (/// f)) as)
  Lam w ps t    -> Lam w ps (t /// f)
  Let w ds t    -> Let w (over (traverse . rhs1) (//  f) ds) (t /// f)
  Rec w ds t    -> Rec w (over (traverse . rhs1) (/// f) ds) (t /// f)

(///) :: Expr (Scope i v) -> (Pos -> v -> Expr w) -> Expr (Scope i w)
t /// f = t // (\w x -> dist w (fmap (f w) x))

dist :: Pos -> Scope i (Expr v) -> Expr (Scope i v)
dist w (Bound i x) = Var w (Bound i x)
dist _ (Free t)    = fmap Free t

deriving instance Functor     Expr
deriving instance Foldable    Expr
deriving instance Traversable Expr
