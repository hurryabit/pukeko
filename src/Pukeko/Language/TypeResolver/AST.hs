-- | AST generated by the introduction of de Bruijn indices.
module Pukeko.Language.TypeResolver.AST
  ( TypeCon
  , ExprCon
  , Module
  , TopLevel (..)
  , Defn
  , Expr (..)
  , Altn
  , Patn
  , fvExpr
  )
where

import           Data.Maybe  (mapMaybe)
import           Data.Monoid
import           Data.Set    (Set)
import qualified Data.Set    as Set

import           Pukeko.Pos
import           Pukeko.Language.Base.AST
import qualified Pukeko.Language.Ident    as Id
import qualified Pukeko.Language.Type     as Ty

type TypeCon = Ty.ADT Id.Con
type ExprCon = Ty.Constructor TypeCon

type Module = [TopLevel]

data TopLevel
  =           TypDef Pos [Ty.ADT TypeCon]
  |           Val    Pos Id.EVar (Ty.Type TypeCon Ty.Closed)
  | forall n. TopLet Pos (Vector n (Defn Id.EVar))
  | forall n. TopRec Pos (Vector n (Defn (FinScope n Id.EVar)))
  |           Asm    Pos Id.EVar String

type Defn = StdDefn Expr

data Expr v
  =           Var Pos v
  |           Con Pos ExprCon
  |           Num Pos Int
  |           App Pos (Expr v) [Expr v]
  -- |           If  Pos (Expr v) (Expr v) (Expr v)
  |           Mat Pos (Expr v) [Altn v]
  | forall n. Lam Pos (Vector n Bind)                  (Expr (FinScope n v))
  | forall n. Let Pos (Vector n (Defn v))              (Expr (FinScope n v))
  | forall n. Rec Pos (Vector n (Defn (FinScope n v))) (Expr (FinScope n v))

type Altn = StdAltn ExprCon Expr

type Patn = StdPatn ExprCon

-- * Functions

fvDefn :: IsVar v => Defn v -> Set v
fvDefn (MkDefn _ _ t) = fvExpr t

fvExpr :: IsVar v => Expr v -> Set v
fvExpr = \case
  Var _ x       -> Set.singleton x
  Con{}         -> mempty
  Num{}         -> mempty
  App _ t  us   -> foldMap fvExpr (t:us)
  -- If  _ t  u  v -> foldMap fvExpr [t,u,v]
  Mat _ t  as   -> fvExpr t <> foldMap fvAltn as
  Lam _ _  t    -> fvScope (fvExpr t)
  Let _ ds t    -> foldMap fvDefn ds <> fvScope (fvExpr t)
  Rec _ ds t    -> foldMap (fvScope . fvDefn) ds <> fvScope (fvExpr t)

fvAltn :: IsVar v => Altn v -> Set v
fvAltn = undefined

fvScope :: (IsVar v) =>  Set (Scope i v) -> Set v
fvScope = Set.fromAscList . mapMaybe f . Set.toAscList
  where
    f = \case
      Bound{} -> Nothing
      Free x  -> Just x

-- * Instances

instance HasPos (Expr v) where
  pos f = \case
    Var w x       -> fmap (\w' -> Var w' x      ) (f w)
    Con w c       -> fmap (\w' -> Con w' c      ) (f w)
    Num w n       -> fmap (\w' -> Num w' n      ) (f w)
    App w t  us   -> fmap (\w' -> App w' t  us  ) (f w)
    -- If  w t  u  v -> fmap (\w' -> If  w' t  u  v) (f w)
    Mat w ts as   -> fmap (\w' -> Mat w' ts as  ) (f w)
    Lam w ps t    -> fmap (\w' -> Lam w' ps t   ) (f w)
    Let w ds t    -> fmap (\w' -> Let w' ds t   ) (f w)
    Rec w ds t    -> fmap (\w' -> Rec w' ds t   ) (f w)

deriving instance Functor     Expr
deriving instance Foldable    Expr
deriving instance Traversable Expr
