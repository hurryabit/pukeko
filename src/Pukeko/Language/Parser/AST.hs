-- | AST generated by the parser.
module Pukeko.Language.Parser.AST
  ( -- * Types
    TCon
  , DCon
  , Module
  , TopLevel (..)
  , Defn
  , Expr (..)
  , Altn (..)
  , Patn

    -- * Smart constructors
  , mkApp
  , mkAppOp
  , mkIf
  , mkLam
  )
where

import           Pukeko.Pos
import           Pukeko.Language.AST.Std (GenDefn (..), Patn (..), Bind (..))
import qualified Pukeko.Language.AST.ConDecl as Con
import qualified Pukeko.Language.Ident       as Id
import           Pukeko.Language.Type

type TCon = Id.TCon
type DCon = Id.DCon

type Module = [TopLevel]

data TopLevel
  = TLTyp Pos [Con.TConDecl]
  | TLVal Pos Id.EVar (Type Id.TVar)
  | TLLet Pos [Defn Id.EVar]
  | TLRec Pos [Defn Id.EVar]
  | TLAsm Pos Id.EVar String

type Defn = GenDefn Expr

data Expr v
  = EVar Pos v
  | ECon Pos DCon
  | ENum Pos Int
  | EApp Pos (Expr v) [Expr v]
  | EMat Pos (Expr v) [Altn v]
  | ELam Pos [Bind]   (Expr v)
  | ELet Pos [Defn v] (Expr v)
  | ERec Pos [Defn v] (Expr v)

data Altn v = MkAltn Pos Patn (Expr v)

mkApp :: Pos -> Expr v -> [Expr v] -> Expr v
mkApp pos fun args
  | null args = fun
  | otherwise = EApp pos fun args

mkAppOp :: String -> Pos -> Expr Id.EVar -> Expr Id.EVar -> Expr Id.EVar
mkAppOp sym pos arg1 arg2 =
  let fun = EVar pos (Id.op sym)
  in  EApp pos fun [arg1, arg2]

mkIf :: Pos -> Expr v -> Pos -> Expr v -> Pos -> Expr v -> Expr v
mkIf wt t wu u wv v =
  EMat wt t [ MkAltn wu (PCon wu (Id.dcon "True") []) u
            , MkAltn wv (PCon wv (Id.dcon "False") []) v
            ]

mkLam :: Pos -> [Bind] -> Expr v -> Expr v
mkLam pos patns expr
  | null patns = expr
  | otherwise  = ELam pos patns expr
