-- | AST generated by the parser.
module Pukeko.Language.Parser.AST
  ( -- * Types
    TCon
  , DCon
  , Module
  , TopLevel (..)
  , TConDecl (..)
  , DConDecl (..)
  , Defn (..)
  , Expr (..)
  , Altn (..)
  , Patn (..)
  , Bind (..)

    -- * Smart constructors
  , mkApp
  , mkAppOp
  , mkIf
  , mkLam
  )
where

import           Pukeko.Pos
import qualified Pukeko.Language.Ident   as Id
import           Pukeko.Language.Type

type TCon = Id.TCon
type DCon = Id.DCon

type Module = [TopLevel]

data TopLevel
  = TLTyp Pos [TConDecl]
  | TLVal Pos Id.EVar (Type Id.TVar)
  | TLLet Pos [Defn Id.EVar]
  | TLRec Pos [Defn Id.EVar]
  | TLAsm Pos Id.EVar String

data TConDecl = MkTConDecl
  { _tname  :: Id.TCon
  , _params :: [Id.TVar]
  , _dcons  :: [DConDecl]
  }

data DConDecl = MkDConDecl
  { _dname  :: Id.DCon
  , _fields :: [Type Id.TVar]
  }

data Defn v = MkDefn Pos Id.EVar (Expr v)

data Expr v
  = EVar Pos v
  | ECon Pos DCon
  | ENum Pos Int
  | EApp Pos (Expr v) [Expr v]
  | EMat Pos (Expr v) [Altn v]
  | ELam Pos [Bind]   (Expr v)
  | ELet Pos [Defn v] (Expr v)
  | ERec Pos [Defn v] (Expr v)

data Altn v = MkAltn Pos Patn (Expr v)

data Patn
  = PVar     Bind
  | PCon Pos Id.DCon [Patn]

data Bind
  = BWild Pos
  | BName Pos Id.EVar

mkApp :: Pos -> Expr v -> [Expr v] -> Expr v
mkApp pos fun args
  | null args = fun
  | otherwise = EApp pos fun args

mkAppOp :: String -> Pos -> Expr Id.EVar -> Expr Id.EVar -> Expr Id.EVar
mkAppOp sym pos arg1 arg2 =
  let fun = EVar pos (Id.op sym)
  in  EApp pos fun [arg1, arg2]

mkIf :: Pos -> Expr v -> Pos -> Expr v -> Pos -> Expr v -> Expr v
mkIf wt t wu u wv v =
  EMat wt t [ MkAltn wu (PCon wu (Id.dcon "True") []) u
            , MkAltn wv (PCon wv (Id.dcon "False") []) v
            ]

mkLam :: Pos -> [Bind] -> Expr v -> Expr v
mkLam pos patns expr
  | null patns = expr
  | otherwise  = ELam pos patns expr
