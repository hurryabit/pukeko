-- | AST generated by the parser.
module Pukeko.AST.Surface
  ( -- * Types
    TCon
  , DCon
  , Package (..)
  , Module (..)
  , Decl (..)
  , TConDecl (..)
  , DConDecl (..)
  , SignDecl (..)
  , ClssDecl (..)
  , InstDecl (..)
  , PrimDecl (..)
  , Type (..)
  , TypeCstr (..)
  , TypeScheme (..)
  , Defn (..)
  , Expr (..)
  , Altn (..)
  , Patn (..)

    -- * Smart constructors
  , mkApp
  , mkAppOp
  , mkIf
  , mkLam
  , mkTApp
  , mkTFun

  , extend
  , type2tvar
  )
where

import Pukeko.Prelude

import qualified Pukeko.AST.Identifier as Id

type TCon = Id.TCon
type DCon = Id.DCon

data Package = MkPackage
  { _pkg2root    :: FilePath
  , _pkg2modules :: [Module]
  }

data Module = MkModule
  { _mod2file    :: FilePath
  , _mod2imports :: [FilePath]
  , _mod2decls   :: [Lctd Decl]
  }

data Decl
  = DType (NonEmpty (Lctd TConDecl))
  | DSign SignDecl
  | DClss ClssDecl
  | DInst InstDecl
  | DDefn (Defn Id.EVar)
  | DPrim PrimDecl

data TConDecl = MkTConDecl
  { _tcon2name  :: Id.TCon
  , _tcon2prms  :: [Id.TVar]
    -- FIXME: Use a proper type to distinguish between 'type' and 'data'.
  , _tcon2dcons :: Either Type [Lctd DConDecl]
  }

data DConDecl = MkDConDecl
  { _dcon2name :: Id.DCon
  , _dcon2flds :: [Type]
  }

data SignDecl = MkSignDecl
  { _sign2func :: Id.EVar
  , _sign2type :: TypeScheme
  }

data ClssDecl = MkClssDecl
  { _clss2name  :: Id.Clss
  , _clss2prm   :: Id.TVar
  , _clss2mthds :: [SignDecl]
  }

data InstDecl = MkInstDecl
  { _inst2clss  :: Id.Clss
  , _inst2tcon  :: Id.TCon
  , _inst2tvars :: [Id.TVar]
  , _inst2cstr  :: TypeCstr
  , _inst2defns :: [Lctd (Defn Id.EVar)]
  }

data PrimDecl = MkPrimDecl
  { _prim2func :: Id.EVar
  , _prim2prim :: String
  }

data Type
  = TVar Id.TVar
  | TCon Id.TCon
  | TArr
  | TApp Type Type

data TypeCstr = MkTypeCstr [(Id.Clss, Id.TVar)]

data TypeScheme = MkTypeScheme TypeCstr Type

data Defn v = MkDefn Id.EVar (Expr v)

data Expr v
  = ELoc (Lctd (Expr v))
  | EVar v
  | ECon DCon
  | ENum Int
  | EApp (Expr v) (NonEmpty (Expr v))
  | EMat (Expr v) [Altn v]
  | ELam (NonEmpty Id.EVar) (Expr v)
  | ELet (NonEmpty (Lctd (Defn v))) (Expr v)
  | ERec (NonEmpty (Lctd (Defn v))) (Expr v)

data Altn v = MkAltn Patn (Expr v)

data Patn
  = PWld
  | PVar Id.EVar
  | PCon Id.DCon [Patn]

extend :: Module -> Package -> Package
extend mdl (MkPackage _ mdls) = MkPackage (_mod2file mdl) (mdls ++ [mdl])

mkApp :: Expr v -> [Expr v] -> Expr v
mkApp fun = \case
  []       -> fun
  arg:args -> EApp fun (arg :| args)

mkAppOp :: String -> Expr Id.EVar -> Expr Id.EVar -> Expr Id.EVar
mkAppOp sym arg1 arg2 =
  let fun = EVar (Id.op sym)
  in  EApp fun (arg1 :| [arg2])

mkIf :: Expr v -> Expr v -> Expr v -> Expr v
mkIf t u v =
  EMat t [ MkAltn (PCon (Id.dcon "True") []) u
         , MkAltn (PCon (Id.dcon "False") []) v
         ]

mkLam :: [Id.EVar] -> Expr v -> Expr v
mkLam = \case
  []     -> id
  (b:bs) -> ELam (b :| bs)

mkTApp :: Type -> [Type] -> Type
mkTApp = foldl TApp

mkTFun :: Type -> Type -> Type
mkTFun tx ty = mkTApp TArr [tx, ty]

type2tvar :: Traversal' Type Id.TVar
type2tvar f = \case
  TVar v     -> TVar <$> f v
  TCon c     -> pure (TCon c)
  TArr       -> pure TArr
  TApp tf tp -> TApp <$> type2tvar f tf <*> type2tvar f tp


deriving instance Show Module
deriving instance Show Decl
deriving instance Show TConDecl
deriving instance Show DConDecl
deriving instance Show SignDecl
deriving instance Show ClssDecl
deriving instance Show InstDecl
deriving instance Show PrimDecl
deriving instance Show Type
deriving instance Show TypeCstr
deriving instance Show TypeScheme
deriving instance Show v => Show (Defn v)
deriving instance Show v => Show (Expr v)
deriving instance Show v => Show (Altn v)
deriving instance Show Patn
