-- | AST generated by the parser.
module Pukeko.AST.Surface
  ( -- * Types
    TCon
  , DCon
  , Package (..)
  , Module (..)
  , Decl (..)
  , TConDecl (..)
  , DConDecl (..)
  , SignDecl (..)
  , ClssDecl (..)
  , InstDecl (..)
  , PrimDecl (..)
  , Type (..)
  , TypeCstr (..)
  , TypeScheme (..)
  , Defn (..)
  , Expr (..)
  , Bind (..)
  , Altn (..)
  , Patn (..)

    -- * Smart constructors
  , mkApp
  , mkAppOp
  , mkIf
  , mkLam
  , mkTApp
  , mkTFun

  , extend
  , type2tvar
  )
where

import Pukeko.Prelude

import qualified Pukeko.AST.Identifier as Id

type TCon = Id.TCon
type DCon = Id.DCon

data Package = MkPackage
  { _pkg2root    :: FilePath
  , _pkg2modules :: [Module]
  }

data Module = MkModule
  { _mod2file    :: FilePath
  , _mod2imports :: [FilePath]
  , _mod2decls   :: [Decl]
  }

data Decl
  = DType (NonEmpty TConDecl)
  | DSign SignDecl
  | DClss ClssDecl
  | DInst InstDecl
  | DLet  (NonEmpty (Defn Id.EVar))
  | DRec  (NonEmpty (Defn Id.EVar))
  | DPrim PrimDecl

data TConDecl = MkTConDecl
  { _tcon2pos   :: Pos
  , _tcon2name  :: Id.TCon
  , _tcon2prms  :: [Id.TVar]
  , _tcon2dcons :: [DConDecl]
  }

data DConDecl = MkDConDecl
  { _dcon2pos  :: Pos
  , _dcon2name :: Id.DCon
  , _dcon2flds :: [Type]
  }

data SignDecl = MkSignDecl
  { _sign2pos  :: Pos
  , _sign2func :: Id.EVar
  , _sign2type :: TypeScheme
  }

data ClssDecl = MkClssDecl
  { _clss2pos   :: Pos
  , _clss2name  :: Id.Clss
  , _clss2prm   :: Id.TVar
  , _clss2mthds :: [SignDecl]
  }

data InstDecl = MkInstDecl
  { _inst2pos   :: Pos
  , _inst2clss  :: Id.Clss
  , _inst2tcon  :: Id.TCon
  , _inst2tvars :: [Id.TVar]
  , _inst2cstr  :: TypeCstr
  , _inst2defns :: [Defn Id.EVar]
  }

data PrimDecl = MkPrimDecl
  { _prim2pos  :: Pos
  , _prim2func :: Id.EVar
  , _prim2prim :: String
  }

data Type
  = TVar Id.TVar
  | TCon Id.TCon
  | TArr
  | TApp Type Type

data TypeCstr = MkTypeCstr [(Id.Clss, Id.TVar)]

data TypeScheme = MkTypeScheme TypeCstr Type

data Defn v = MkDefn Bind (Expr v)

data Expr v
  = EVar Pos v
  | ECon Pos DCon
  | ENum Pos Int
  | EApp Pos (Expr v) (NonEmpty (Expr v))
  | EMat Pos (Expr v) [Altn v]
  | ELam Pos (NonEmpty Bind) (Expr v)
  | ELet Pos (NonEmpty (Defn v)) (Expr v)
  | ERec Pos (NonEmpty (Defn v)) (Expr v)

data Bind = MkBind Pos Id.EVar

data Altn v = MkAltn Pos Patn (Expr v)

data Patn
  = PWld Pos
  | PVar Pos Id.EVar
  | PCon Pos Id.DCon [Patn]

extend :: Module -> Package -> Package
extend mdl (MkPackage _ mdls) = MkPackage (_mod2file mdl) (mdls ++ [mdl])

mkApp :: Pos -> Expr v -> [Expr v] -> Expr v
mkApp pos fun = \case
  []       -> fun
  arg:args -> EApp pos fun (arg :| args)

mkAppOp :: String -> Pos -> Expr Id.EVar -> Expr Id.EVar -> Expr Id.EVar
mkAppOp sym pos arg1 arg2 =
  let fun = EVar pos (Id.op sym)
  in  EApp pos fun (arg1 :| [arg2])

mkIf :: Pos -> Expr v -> Pos -> Expr v -> Pos -> Expr v -> Expr v
mkIf wt t wu u wv v =
  EMat wt t [ MkAltn wu (PCon wu (Id.dcon "True") []) u
            , MkAltn wv (PCon wv (Id.dcon "False") []) v
            ]

mkLam :: Pos -> [Bind] -> Expr v -> Expr v
mkLam w = \case
  []     -> id
  (b:bs) -> ELam w (b :| bs)

mkTApp :: Type -> [Type] -> Type
mkTApp = foldl TApp

mkTFun :: Type -> Type -> Type
mkTFun tx ty = mkTApp TArr [tx, ty]

type2tvar :: Traversal' Type Id.TVar
type2tvar f = \case
  TVar v     -> TVar <$> f v
  TCon c     -> pure (TCon c)
  TArr       -> pure TArr
  TApp tf tp -> TApp <$> type2tvar f tf <*> type2tvar f tp


deriving instance Show Module
deriving instance Show Decl
deriving instance Show TConDecl
deriving instance Show DConDecl
deriving instance Show SignDecl
deriving instance Show ClssDecl
deriving instance Show InstDecl
deriving instance Show PrimDecl
deriving instance Show Type
deriving instance Show TypeCstr
deriving instance Show TypeScheme
deriving instance Show v => Show (Defn v)
deriving instance Show v => Show (Expr v)
deriving instance Show v => Show (Altn v)
deriving instance Show Patn
deriving instance Show Bind
