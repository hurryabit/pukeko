-- | AST generated by the parser.
module Pukeko.AST.Surface
  ( -- * Types
    TCon
  , DCon
  , Package (..)
  , Module (..)
  , Decl (..)
  , TConDecl (..)
  , DConDecl (..)
  , SignDecl (..)
  , ClssDecl (..)
  , InstDecl (..)
  , ExtnDecl (..)
  , InfxDecl (..)
  , TypeAtom (..)
  , Type (..)
  , TypeCstr (..)
  , TypeScheme (..)
  , CoercionDir (..)
  , Coercion (..)
  , Defn (..)
  , Expr (..)
  , Altn (..)
  , Patn (..)

    -- * Smart constructors
  , mkApp
  , mkIf
  , mkLam
  , mkTApp
  , mkTFun

  , extend
  , type2tvar
  )
where

import Pukeko.Prelude

import qualified Pukeko.AST.Identifier as Id
import qualified Pukeko.AST.Operator   as Op

type TCon = Id.TCon
type DCon = Id.DCon

data Package = MkPackage
  { _pkg2root    :: FilePath
  , _pkg2modules :: [Module]
  }

data Module = MkModule
  { _mod2file    :: FilePath
  , _mod2imports :: [FilePath]
  , _mod2decls   :: [Decl]
  }

data Decl
  = DType TConDecl
  | DSign SignDecl
  | DClss ClssDecl
  | DInst InstDecl
  | DDefn (Defn Id.EVar)
  | DExtn ExtnDecl
  | DInfx InfxDecl

data TConDecl = MkTConDecl
  { _tcon2name  :: Lctd Id.TCon
  , _tcon2prms  :: [Id.TVar]
    -- FIXME: Use a proper type to distinguish between 'type' and 'data'.
  , _tcon2dcons :: Either Type [DConDecl]
  }

data DConDecl = MkDConDecl
  { _dcon2name :: Lctd Id.DCon
  , _dcon2flds :: [Type]
  }

data SignDecl = MkSignDecl
  { _sign2func :: Lctd Id.EVar
  , _sign2type :: TypeScheme
  }

data ClssDecl = MkClssDecl
  { _clss2name  :: Lctd Id.Clss
  , _clss2prm   :: Id.TVar
  , _clss2mthds :: [SignDecl]
  }

data InstDecl = MkInstDecl
  { _inst2clss  :: Lctd Id.Clss
  , _inst2atom  :: TypeAtom
  , _inst2tvars :: [Id.TVar]
  , _inst2cstr  :: TypeCstr
  , _inst2defns :: [Defn Id.EVar]
  }

data ExtnDecl = MkExtnDecl
  { _extn2func :: Lctd Id.EVar
  , _extn2name :: String
  }

data InfxDecl = MkInfxDecl
  { _infx2op   :: Lctd Op.Binary
  , _infx2func :: Id.EVar
  }

data TypeAtom
  = TAArr
  | TAInt
  | TACon Id.TCon

data Type
  = TVar Id.TVar
  | TAtm TypeAtom
  | TApp Type Type

data TypeCstr = MkTypeCstr [(Id.Clss, Id.TVar)]

data TypeScheme = MkTypeScheme TypeCstr Type

data CoercionDir = Inject | Project

data Coercion = MkCoercion CoercionDir Id.TCon

data Defn v = MkDefn (Lctd Id.EVar) (Expr v)

data Expr v
  = ELoc (Lctd (Expr v))
  | EVar v
  | ECon DCon
  | ENum Int
  | EApp (Expr v) (NonEmpty (Expr v))
  | EOpp Op.Binary (Expr v) (Expr v)
  | EMat (Expr v) [Altn v]
  | ELam (NonEmpty (Lctd Id.EVar)) (Expr v)
  | ELet (NonEmpty (Defn v)) (Expr v)
  | ERec (NonEmpty (Defn v)) (Expr v)
  | ECoe Coercion (Expr v)

data Altn v = MkAltn Patn (Expr v)

data Patn
  = PWld
  | PVar Id.EVar
  | PCon Id.DCon [Patn]

extend :: Module -> Package -> Package
extend mdl (MkPackage _ mdls) = MkPackage (_mod2file mdl) (mdls ++ [mdl])

mkApp :: Expr v -> [Expr v] -> Expr v
mkApp fun = \case
  []       -> fun
  arg:args -> EApp fun (arg :| args)

mkIf :: Expr v -> Expr v -> Expr v -> Expr v
mkIf t u v =
  EMat t [ MkAltn (PCon (Id.dcon "True") []) u
         , MkAltn (PCon (Id.dcon "False") []) v
         ]

mkLam :: [Lctd Id.EVar] -> Expr v -> Expr v
mkLam = \case
  []     -> id
  (b:bs) -> ELam (b :| bs)

mkTApp :: Type -> [Type] -> Type
mkTApp = foldl TApp

mkTFun :: Type -> Type -> Type
mkTFun tx ty = mkTApp (TAtm TAArr) [tx, ty]

type2tvar :: Traversal' Type Id.TVar
type2tvar f = \case
  TVar v     -> TVar <$> f v
  TAtm a     -> pure (TAtm a)
  TApp tf tp -> TApp <$> type2tvar f tf <*> type2tvar f tp


deriving instance Show Module
deriving instance Show Decl
deriving instance Show TConDecl
deriving instance Show DConDecl
deriving instance Show SignDecl
deriving instance Show ClssDecl
deriving instance Show InstDecl
deriving instance Show ExtnDecl
deriving instance Show InfxDecl
deriving instance Show TypeAtom
deriving instance Show Type
deriving instance Show TypeCstr
deriving instance Show TypeScheme
deriving instance Show CoercionDir
deriving instance Show Coercion
deriving instance Show v => Show (Defn v)
deriving instance Show v => Show (Expr v)
deriving instance Show v => Show (Altn v)
deriving instance Show Patn
