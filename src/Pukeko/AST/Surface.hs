-- | AST generated by the parser.
module Pukeko.AST.Surface
  ( -- * Types
    TCon
  , DCon
  , Module
  , TopLevel (..)
  , TConDecl (..)
  , DConDecl (..)
  , Defn (..)
  , Expr (..)
  , Bind (..)
  , Altn (..)
  , Patn (..)

    -- * Smart constructors
  , mkApp
  , mkAppOp
  , mkIf
  , mkLam
  )
where

import Pukeko.Prelude

import qualified Pukeko.AST.Identifier as Id
import           Pukeko.AST.Type

type TCon = Id.TCon
type DCon = Id.DCon

type Module = [TopLevel]

data TopLevel
  = TLTyp Pos (NonEmpty TConDecl)
  | TLVal Pos Id.EVar (Type Id.TVar)
  | TLLet Pos (NonEmpty (Defn Id.EVar))
  | TLRec Pos (NonEmpty (Defn Id.EVar))
  | TLAsm Pos Id.EVar String

data TConDecl = MkTConDecl
  { _tname  :: Id.TCon
  , _params :: [Id.TVar]
  , _dcons  :: [DConDecl]
  }

data DConDecl = MkDConDecl
  { _dname  :: Id.DCon
  , _fields :: [Type Id.TVar]
  }

data Defn v = MkDefn Bind (Expr v)

data Expr v
  = EVar Pos v
  | ECon Pos DCon
  | ENum Pos Int
  | EApp Pos (Expr v) (NonEmpty (Expr v))
  | EMat Pos (Expr v) [Altn v]
  | ELam Pos (NonEmpty Bind) (Expr v)
  | ELet Pos (NonEmpty (Defn v)) (Expr v)
  | ERec Pos (NonEmpty (Defn v)) (Expr v)

data Bind = MkBind Pos Id.EVar

data Altn v = MkAltn Pos Patn (Expr v)

data Patn
  = PWld Pos
  | PVar Pos Id.EVar
  | PCon Pos Id.DCon [Patn]

mkApp :: Pos -> Expr v -> [Expr v] -> Expr v
mkApp pos fun = \case
  []       -> fun
  arg:args -> EApp pos fun (arg :| args)

mkAppOp :: String -> Pos -> Expr Id.EVar -> Expr Id.EVar -> Expr Id.EVar
mkAppOp sym pos arg1 arg2 =
  let fun = EVar pos (Id.op sym)
  in  EApp pos fun (arg1 :| [arg2])

mkIf :: Pos -> Expr v -> Pos -> Expr v -> Pos -> Expr v -> Expr v
mkIf wt t wu u wv v =
  EMat wt t [ MkAltn wu (PCon wu (Id.dcon "True") []) u
            , MkAltn wv (PCon wv (Id.dcon "False") []) v
            ]

mkLam :: Pos -> [Bind] -> Expr v -> Expr v
mkLam w = \case
  []     -> id
  (b:bs) -> ELam w (b :| bs)
