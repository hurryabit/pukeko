-- | AST generated by the parser.
module Pukeko.AST.Surface
  ( -- * Types
    Package (..)
  , Module (..)
  , Decl (..)
  , TConDecl (..)
  , DConDecl (..)
  , SignDecl (..)
  , ClssDecl (..)
  , InstDecl (..)
  , ExtnDecl (..)
  , InfxDecl (..)
  , TypeAtom (..)
  , Type (..)
  , TypeCstr (..)
  , TypeScheme (..)
  , CoercionDir (..)
  , Coercion (..)
  , Defn (..)
  , Expr (..)
  , Altn (..)
  , Patn (..)
  , Name
  , LctdName

    -- * Smart constructors
  , mkApp
  , mkIf
  , mkLam
  , mkTApp
  , mkTFun

  , extend
  , freeTVars
  )
where

import Pukeko.Prelude

import qualified Data.Map.Extended as Map

import           Pukeko.AST.Name       hiding (Name)
import qualified Pukeko.AST.Operator   as Op

type Name (nsp :: NameSpace) = Tagged nsp String
type LctdName nsp = Lctd (Name nsp)

data Package = MkPackage
  { _pkg2root    :: FilePath
  , _pkg2modules :: [Module]
  }

data Module = MkModule
  { _mod2file    :: FilePath
  , _mod2imports :: [FilePath]
  , _mod2decls   :: [Decl]
  }

data Decl
  = DType TConDecl
  | DSign SignDecl
  | DClss ClssDecl
  | DInst InstDecl
  | DDefn (Defn (LctdName EVar))
  | DExtn ExtnDecl
  | DInfx InfxDecl

data TConDecl = MkTConDecl
  { _tcon2name  :: LctdName TCon
  , _tcon2prms  :: [LctdName TVar]
    -- FIXME: Use a proper type to distinguish between 'type' and 'data'.
  , _tcon2dcons :: Either Type [DConDecl]
  }

data DConDecl = MkDConDecl
  { _dcon2name :: LctdName DCon
  , _dcon2flds :: [Type]
  }

data SignDecl = MkSignDecl
  { _sign2func :: LctdName EVar
  , _sign2type :: TypeScheme
  }

data ClssDecl = MkClssDecl
  { _clss2name  :: LctdName Clss
  , _clss2prm   :: LctdName TVar
  , _clss2mthds :: [SignDecl]
  }

data InstDecl = MkInstDecl
  { _inst2clss  :: LctdName Clss
  , _inst2atom  :: TypeAtom
  , _inst2tvars :: [LctdName TVar]
  , _inst2cstr  :: TypeCstr
  , _inst2defns :: [Defn (LctdName EVar)]
  }

data ExtnDecl = MkExtnDecl
  { _extn2func :: LctdName EVar
  , _extn2name :: String
  }

data InfxDecl = MkInfxDecl
  { _infx2op   :: Lctd Op.Binary
  , _infx2func :: LctdName EVar
  }

data TypeAtom
  = TAArr
  | TAInt
  | TACon (LctdName TCon)

data Type
  = TVar (LctdName TVar)
  | TAtm TypeAtom
  | TApp Type Type

data TypeCstr = MkTypeCstr [(LctdName Clss, LctdName TVar)]

data TypeScheme = MkTypeScheme TypeCstr Type

data CoercionDir = Inject | Project

data Coercion = MkCoercion CoercionDir (LctdName TCon)

data Defn v = MkDefn (LctdName EVar) (Expr v)

data Expr v
  = ELoc (Lctd (Expr v))
  | EVar v
  | ECon (LctdName DCon)
  | ENum Int
  | EApp (Expr v) (NonEmpty (Expr v))
  | EOpp Op.Binary (Expr v) (Expr v)
  | EMat (Expr v) [Altn v]
  | ELam (NonEmpty (LctdName EVar)) (Expr v)
  | ELet (NonEmpty (Defn v)) (Expr v)
  | ERec (NonEmpty (Defn v)) (Expr v)
  | ECoe Coercion (Expr v)

data Altn v = MkAltn Patn (Expr v)

data Patn
  = PWld
  | PVar (LctdName EVar)
  | PCon (LctdName DCon) [Patn]

extend :: Module -> Package -> Package
extend mdl (MkPackage _ mdls) = MkPackage (_mod2file mdl) (mdls ++ [mdl])

mkApp :: Expr v -> [Expr v] -> Expr v
mkApp fun = \case
  []       -> fun
  arg:args -> EApp fun (arg :| args)

mkIf :: Expr v -> Expr v -> Expr v -> Expr v
mkIf t u v =
  EMat t [ MkAltn (PCon (Lctd noPos (Tagged "True" )) []) u
         , MkAltn (PCon (Lctd noPos (Tagged "False")) []) v
         ]

mkLam :: [LctdName EVar] -> Expr v -> Expr v
mkLam = \case
  []     -> id
  (b:bs) -> ELam (b :| bs)

mkTApp :: Type -> [Type] -> Type
mkTApp = foldl TApp

mkTFun :: Type -> Type -> Type
mkTFun tx ty = mkTApp (TAtm TAArr) [tx, ty]

freeTVars :: Type -> Map (Name TVar) (LctdName TVar)
freeTVars = \case
  TVar v -> Map.singleton (unlctd v) v
  TAtm _ -> mempty
  TApp tf ta -> freeTVars tf <> freeTVars ta

deriving instance Show Module
deriving instance Show Decl
deriving instance Show TConDecl
deriving instance Show DConDecl
deriving instance Show SignDecl
deriving instance Show ClssDecl
deriving instance Show InstDecl
deriving instance Show ExtnDecl
deriving instance Show InfxDecl
deriving instance Show TypeAtom
deriving instance Show Type
deriving instance Show TypeCstr
deriving instance Show TypeScheme
deriving instance Show CoercionDir
deriving instance Show Coercion
deriving instance Show v => Show (Defn v)
deriving instance Show v => Show (Expr v)
deriving instance Show v => Show (Altn v)
deriving instance Show Patn
