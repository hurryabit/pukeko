-- | AST generated by the parser.
module Pukeko.AST.Surface
  ( -- * Types
    Package (..)
  , Module (..)
  , Decl (..)
  , TyConDecl (..)
  , TmConDecl (..)
  , SignDecl (..)
  , ClssDecl (..)
  , InstDecl (..)
  , ExtnDecl (..)
  , InfxDecl (..)
  , TypeAtom (..)
  , Type (..)
  , TypeCstr (..)
  , TypeScheme (..)
  , CoercionDir (..)
  , Coercion (..)
  , Bind (..)
  , Expr (..)
  , Altn (..)
  , Patn (..)
  , Name
  , LctdName

    -- * Smart constructors
  , mkApp
  , mkIf
  , mkLam
  , mkTApp
  , mkTFun

  , extend
  , freeTyVars
  )
where

import Pukeko.Prelude

import qualified Data.Map.Extended as Map

import           Pukeko.AST.Name       hiding (Name)
import qualified Pukeko.AST.Operator   as Op

type Name (nsp :: NameSpace) = Tagged nsp String
type LctdName nsp = Lctd (Name nsp)

data Package = MkPackage
  { _pkg2root    :: FilePath
  , _pkg2modules :: [Module]
  }

data Module = MkModule
  { _mod2file    :: FilePath
  , _mod2imports :: [FilePath]
  , _mod2decls   :: [Decl]
  }

data Decl
  = DType TyConDecl
  | DSign SignDecl
  | DClss ClssDecl
  | DInst InstDecl
  | DDefn (Bind (LctdName 'TmVar))
  | DExtn ExtnDecl
  | DInfx InfxDecl

data TyConDecl = MkTyConDecl
  { _tycon2name   :: LctdName 'TyCon
  , _tycon2params :: [LctdName 'TyVar]
    -- FIXME: Use a proper type to distinguish between 'type' and 'data'.
  , _tycon2tmcons :: Either Type [TmConDecl]
  }

data TmConDecl = MkTmConDecl
  { _tmcon2name   :: LctdName 'TmCon
  , _tmcon2fields :: [Type]
  }

data SignDecl = MkSignDecl
  { _sign2func :: LctdName 'TmVar
  , _sign2type :: TypeScheme
  }

data ClssDecl = MkClssDecl
  { _clss2name  :: LctdName 'TyCon
  , _clss2prm   :: LctdName 'TyVar
  , _clss2super :: Maybe (LctdName 'TyCon, LctdName 'TyVar)
  , _clss2mthds :: [SignDecl]
  }

data InstDecl = MkInstDecl
  { _inst2name  :: LctdName 'TmVar
  , _inst2clss  :: LctdName 'TyCon
  , _inst2atom  :: TypeAtom
  , _inst2tvars :: [LctdName 'TyVar]
  , _inst2cstr  :: TypeCstr
  , _inst2defns :: [Bind (LctdName 'TmVar)]
  }

data ExtnDecl = MkExtnDecl
  { _extn2func :: LctdName 'TmVar
  , _extn2name :: String
  }

data InfxDecl = MkInfxDecl
  { _infx2op   :: Lctd Op.Binary
  , _infx2func :: LctdName 'TmVar
  }

data TypeAtom
  = TAArr
  | TAInt
  | TACon (LctdName 'TyCon)

data Type
  = TVar (LctdName 'TyVar)
  | TAtm TypeAtom
  | TApp Type Type

newtype TypeCstr = MkTypeCstr [(LctdName 'TyCon, LctdName 'TyVar)]

data TypeScheme = MkTypeScheme TypeCstr Type

data CoercionDir = Inject | Project

data Coercion = MkCoercion CoercionDir (LctdName 'TyCon)

data Bind v = MkBind (LctdName 'TmVar) (Expr v)

data Expr v
  = ELoc (Lctd (Expr v))
  | EVar v
  | ECon (LctdName 'TmCon)
  | ENum Int
  | EApp (Expr v) (NonEmpty (Expr v))
  | EOpp Op.Binary (Expr v) (Expr v)
  | EMat (Expr v) [Altn v]
  | ELam (NonEmpty (LctdName 'TmVar)) (Expr v)
  | ELet (NonEmpty (Bind v)) (Expr v)
  | ERec (NonEmpty (Bind v)) (Expr v)
  | ECoe Coercion (Expr v)

data Altn v = MkAltn Patn (Expr v)

data Patn
  = PWld
  | PVar (LctdName 'TmVar)
  | PCon (LctdName 'TmCon) [Patn]

extend :: Module -> Package -> Package
extend mdl (MkPackage _ mdls) = MkPackage (_mod2file mdl) (mdls ++ [mdl])

mkApp :: Expr v -> [Expr v] -> Expr v
mkApp fun = \case
  []       -> fun
  arg:args -> EApp fun (arg :| args)

mkIf :: Expr v -> Expr v -> Expr v -> Expr v
mkIf t u v =
  EMat t [ MkAltn (PCon (Lctd noPos (Tagged "True" )) []) u
         , MkAltn (PCon (Lctd noPos (Tagged "False")) []) v
         ]

mkLam :: [LctdName 'TmVar] -> Expr v -> Expr v
mkLam = \case
  []     -> id
  (b:bs) -> ELam (b :| bs)

mkTApp :: Type -> [Type] -> Type
mkTApp = foldl TApp

mkTFun :: Type -> Type -> Type
mkTFun tx ty = mkTApp (TAtm TAArr) [tx, ty]

freeTyVars :: Type -> Map (Name 'TyVar) (LctdName 'TyVar)
freeTyVars = \case
  TVar v -> Map.singleton (unlctd v) v
  TAtm _ -> mempty
  TApp tf ta -> freeTyVars tf <> freeTyVars ta

deriving instance Show Module
deriving instance Show Decl
deriving instance Show TyConDecl
deriving instance Show TmConDecl
deriving instance Show SignDecl
deriving instance Show ClssDecl
deriving instance Show InstDecl
deriving instance Show ExtnDecl
deriving instance Show InfxDecl
deriving instance Show TypeAtom
deriving instance Show Type
deriving instance Show TypeCstr
deriving instance Show TypeScheme
deriving instance Show CoercionDir
deriving instance Show Coercion
deriving instance Show v => Show (Bind v)
deriving instance Show v => Show (Expr v)
deriving instance Show v => Show (Altn v)
deriving instance Show Patn
